import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as d,a as e,b as a,d as s,e as t,r as c}from"./app.d7b34baa.js";const i={},l=t(`<h1 id="浏览器缓存机制-请求头" tabindex="-1"><a class="header-anchor" href="#浏览器缓存机制-请求头" aria-hidden="true">#</a> 浏览器缓存机制-请求头</h1><h3 id="相关头部字段" tabindex="-1"><a class="header-anchor" href="#相关头部字段" aria-hidden="true">#</a> 相关头部字段</h3><p>强缓存：</p><ul><li>Expires</li><li>Cache-Control</li></ul><p>协商缓存：</p><ul><li>Etag、If-None-Match</li><li>Last-Modified、If-Modified-Since</li></ul><blockquote><ol><li>Cach-Control优先级高于Expires；</li><li>Etag/If-Node-Match优先级高于Last-Modified/If-Modified-Since</li></ol></blockquote><h2 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存" aria-hidden="true">#</a> 强缓存</h2><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 HTTP 头信息中的 Expires 属性和 Cache-Control 属性。</p><p>Expires 是 HTTP 1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，Cache-Control 通用消息头字段，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。</p><p>当Expires和Cache-Control的 &quot;max-age&quot; 或者 &quot;s-max-age&quot; 指令同时存在时，会无视Expires，只遵循Cache-Control的指令内容。</p><h3 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control" aria-hidden="true">#</a> Cache-Control</h3><p><strong>缓存请求指令</strong></p><p>客户端可以在 HTTP 请求中使用的标准 Cache-Control 指令。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Cache-Control: max-age=&lt;seconds&gt;
Cache-Control: max-stale[=&lt;seconds&gt;]
Cache-Control: min-fresh=&lt;seconds&gt;
Cache-control: no-cache
Cache-control: no-store
Cache-control: no-transform
Cache-control: only-if-cached
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>缓存响应指令</strong></p><p>服务器可以在响应中使用的标准 Cache-Control 指令。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Cache-control: must-revalidate
Cache-control: no-cache
Cache-control: no-store
Cache-control: no-transform
Cache-control: public
Cache-control: private
Cache-control: proxy-revalidate
Cache-Control: max-age=&lt;seconds&gt;
Cache-control: s-maxage=&lt;seconds&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，还有扩展Cache-Control指令，拓展缓存指令不是核心 HTTP 缓存标准文档的一部分，使用前请注意检查兼容性。</p><h3 id="常用指令内容" tabindex="-1"><a class="header-anchor" href="#常用指令内容" aria-hidden="true">#</a> 常用指令内容</h3><p>不包括实验性指令内容</p><p><strong>可缓存控制</strong></p><table><thead><tr><th>名称</th><th>效果</th></tr></thead><tbody><tr><td><code>public</code></td><td>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容（甚至是Post）。</td></tr><tr><td><code>private</code></td><td>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。</td></tr><tr><td><code>no-cache</code></td><td>强制要求缓存把请求提交给原始服务器进行验证 (协商缓存验证)。</td></tr><tr><td><code>no-store</code></td><td>不使用任何缓存</td></tr></tbody></table><p><strong>缓存时长控制</strong></p><table><thead><tr><th>名称</th><th>效果</th></tr></thead><tbody><tr><td><code>max-age=&lt;seconds&gt;</code></td><td>设置缓存存储的最大周期，超过这个时间缓存被认为过期 (单位秒)。与<code>Expires</code>相反，时间是相对于请求的时间。</td></tr><tr><td><code>s-maxage=&lt;seconds&gt;</code></td><td>覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存 (比如各个代理)，私有缓存会忽略它。</td></tr></tbody></table>`,25),h={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control",target:"_blank",rel:"noopener noreferrer"},p=t(`<h3 id="expires" tabindex="-1"><a class="header-anchor" href="#expires" aria-hidden="true">#</a> Expires</h3><p>Expires 响应头包含日期/时间， 即在此时候之后，响应过期。如果在Cache-Control响应头设置了 &quot;max-age&quot; 或者 &quot;s-max-age&quot; 指令，那么 Expires 头会被忽略。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>Expires<span class="token operator">:</span> Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2015</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> GMT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>与Cache-Control对比可知：</strong></p><p>响应报文中expires的时间值，是一个绝对值（时间点）</p><p>响应报文中Cache-Control为max-age=&lt;seconds&gt;，是相对值（时间差）</p><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h2><p>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 或/和 If-Modified-Since 的请求，均为条件式请求首部。</p><p>If-Modified-Since是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。</p><p>服务器收到请求后，会优先根据 Etag 的值（If-None-Match的字段值与该资源在服务器的Etag值做对比）判断被请求的文件有没有做修改，Etag 值一致则认为没有修改，命中协商缓存，返回 304 状态码；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</p><blockquote><p>ETag 属性之间的比较采用的是弱比较算法，即两个文件除了每个字节都相同外，内容一致也可以认为是相同的。例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的。</p></blockquote><p>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</p>`,13);function u(m,v){const n=c("ExternalLinkIcon");return r(),d("div",null,[l,e("p",null,[a("更多见"),e("a",h,[a("Cache-Control MDN"),s(n)])]),p])}const g=o(i,[["render",u],["__file","浏览器缓存机制-请求头.html.vue"]]);export{g as default};
