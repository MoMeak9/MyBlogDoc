import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as t,a as e,b as s,d as a,e as c,r as d}from"./app.d7b34baa.js";const p={},l=c(`<h1 id="逻辑组合伪类-not-is-where-has" tabindex="-1"><a class="header-anchor" href="#逻辑组合伪类-not-is-where-has" aria-hidden="true">#</a> 逻辑组合伪类 :not() :is :where :has</h1><p>本文将介绍4个逻辑组合伪类，分别是<code>:not()</code> <code>:is</code> <code>:where</code> <code>:has</code> ，这四个伪类的自身优先级为0，这与其他伪类相同，但处理时是将其和括号里的参数作为一个整体计算优先级，这就导致了实际表现出的优先级由参数决定（除了<code>:where()</code> 的优先级总是为 0）。</p><p>目前这四位目前都得到了大多数浏览器的广泛支持，同时非常实用，务必掌握哦~</p><h2 id="否定伪类-not" tabindex="-1"><a class="header-anchor" href="#否定伪类-not" aria-hidden="true">#</a> 否定伪类 :not()</h2><p><code>:not()</code> 伪类用于否定选择器，可以接受一个或多个选择器作为参数，如果元素不匹配参数中的任何一个选择器，则匹配该伪类，它也被称为反选伪类（negation pseudo-class）。</p><ol><li><p><code>:not()</code> 伪类优先级是0，即本身没有任何优先级，其优先级由括号内表达式决定</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">:not(li)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其优先级就是 <code>li</code> 选择器的优先级。</p></li><li><p><code>:not()</code> 伪类可以不断级联</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">body :not(div):not(span)</span> <span class="token punctuation">{</span>
  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表示既不是<code> &lt;div&gt;</code> 也不是<code> &lt;span&gt;</code> 的元素</p></li><li><p><code>:not()</code> 伪类目前已支持多个表达式</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">body :not(div, .fancy)</span> <span class="token punctuation">{</span>
  <span class="token property">text-decoration</span><span class="token punctuation">:</span> overline underline<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表示不是<code>&lt;div&gt; </code>或 <code>.fancy</code> 的元素</p></li></ol><h3 id="告别重置" tabindex="-1"><a class="header-anchor" href="#告别重置" aria-hidden="true">#</a> 告别重置</h3><p><code>:not</code>伪类最大的作用就是可以优化我们过去重置CSS样式的策略，使我们代码更加简介，易于理解，例如：</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.panel</span><span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.panel .active</span><span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上我们可以简写成</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.panel :not(.active)</span><span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似的，希望大家能够培养这种意识，对于遇到需要重置CSS样式的场景，第一反应就是使用<code>:not</code>伪类。</p><h2 id="任意匹配伪类-is" tabindex="-1"><a class="header-anchor" href="#任意匹配伪类-is" aria-hidden="true">#</a> 任意匹配伪类 :is()</h2><h3 id="is-伪类与-matches-伪类及-any-伪类之间的关系" tabindex="-1"><a class="header-anchor" href="#is-伪类与-matches-伪类及-any-伪类之间的关系" aria-hidden="true">#</a> :is()伪类与:matches()伪类及:any()伪类之间的关系</h3>`,14),r=e("code",null,":matches ()",-1),u=e("code",null,":is()",-1),v={href:"https://github.com/w3c/csswg-drafts/issues/3258",target:"_blank",rel:"noopener noreferrer"},h=e("code",null,":is()",-1),m=e("code",null,":not() ",-1),b=c(`<p>也就是说，<code>:matches ()</code>伪类是<code>:is ()</code>伪类的前身。然后很有趣的是<code>:matches ()</code>还有一个被舍弃的前身，那就是<code>:any()</code>伪类，被舍弃的原因是选择器的优先级不准确，<code>:any()</code>伪类会忽略括号里面选择器的优先级，而永远是普通伪类的优先级。</p><p><code>:any()</code>伪类名义上虽然被舍弃了，但是除了 IE/Edge 以外的浏览器都支持，而且很早就支持，现在也都支持，不过都需要添加私有前缀，如<code>-webkit-any()</code>以及<code>-moz-any()</code>。</p><h3 id="用法" tabindex="-1"><a class="header-anchor" href="#用法" aria-hidden="true">#</a> 用法</h3><p><code>:is()</code> 将选择器列表作为参数，并选择该列表中任意一个选择器可以选择的元素。这对于以更紧凑的形式编写大型选择器非常有用。</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token comment">/* 选择 header、main、footer 里的任意一个悬浮状态的段落 */</span>
<span class="token selector">:is(header, main, footer) p:hover</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 以上内容相当于以下内容 */</span>
<span class="token selector">header p:hover,
main p:hover,
footer p:hover</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="is-和-where-的区别" tabindex="-1"><a class="header-anchor" href="#is-和-where-的区别" aria-hidden="true">#</a> :is() 和 :where() 的区别</h3><p>两者的区别在于 <code>:is()</code> 计入整体选择器的优先级（它接受优先级最高参数的优先级），而 <code>:where()</code> 的优先级为 0。</p><p>综上，<code>is()</code>是一个有用但不被迫切需要的伪类，但是还是很实用的</p><h2 id="任意匹配伪类-where" tabindex="-1"><a class="header-anchor" href="#任意匹配伪类-where" aria-hidden="true">#</a> 任意匹配伪类 :where()</h2><p><code>:where()</code>伪类是和<code>:is()</code>伪类一同出现的，它们的含义、语法、作用一模一样。唯一的区别就是优先级不一样，<code>:where()</code> 伪类的优先级永远是 0。例如:</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">:where(.article, section) p</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>的优先级等同于 <code>p</code> 选择器，参数里的选择器的优先级被完全忽略。</p><p>又如:</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">:where(#article, #section) .content</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>的优先级等同于<code>.content</code> 选择器</p><h3 id="可容错选择器解析" tabindex="-1"><a class="header-anchor" href="#可容错选择器解析" aria-hidden="true">#</a> 可容错选择器解析</h3>`,16),k=e("code",null,":is()",-1),g=e("code",null,":where()",-1),_={href:"https://drafts.csswg.org/selectors-4/#typedef-forgiving-selector-list",target:"_blank",rel:"noopener noreferrer"},f=c(`<p>在 CSS 中使用选择器列表时，如果任何选择器无效，则整个列表被视为无效，即如果某个选择器无法解析，则被视为无效，不正确或不受支持的选择器将被忽略，其他选择器将被使用。</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">:is(:valid, :unsupported)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* … */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使在不支持 <code>:unsupported</code> 的浏览器中，仍将正确解析 <code>:valid</code>，而这种写法：</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">:valid,
:unsupported</span> <span class="token punctuation">{</span>
  <span class="token comment">/* … */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在不支持 <code>:unsupported</code> 浏览器中即使它们支持 <code>:valid</code>，仍将忽略。</p><h2 id="关联伪类-has" tabindex="-1"><a class="header-anchor" href="#关联伪类-has" aria-hidden="true">#</a> 关联伪类 :has()</h2><p><code>:has()</code>伪类是一个规范制定得很早但浏览器却迟迟没有支持的伪类。如果浏览器能够支持，其功能会非常强大，因为它可以实现类似“父选择器”和“前面兄弟选择器”的功能（提供了一种针对引用元素选择父元素或者先前的兄弟元素的方法），对CSS 的开发会有颠覆性的影响。</p><p>例如：</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token property">a</span><span class="token punctuation">:</span><span class="token function">has</span><span class="token punctuation">(</span>&gt; svg<span class="token punctuation">)</span> [<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表示匹配包含有<code>&lt;svg&gt;</code>元素的<code>&lt;a&gt;</code>元素，实现的就是“父选择器”的效果，即根据子元素选择父元素。</p><p>又如：</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">h1:has(+ p)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表示匹配后面跟随<code>&lt;p&gt;</code>元素的<code>&lt;h1&gt;</code>元素，实现的就是“前面兄弟选择器”的效果，即根据后面的兄弟元素选择前面的元素。</p>`,13),x={href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:has",target:"_blank",rel:"noopener noreferrer"},y=e("p",null,[e("img",{src:"https://cdn.yihuiblog.top/images/202212161923485.png",alt:"image-20221216192303371"})],-1);function w(S,C){const n=d("ExternalLinkIcon");return i(),t("div",null,[l,e("p",null,[s("2018 年 10 月底，"),r,s("伪类改名为"),u,s("伪类 ("),e("a",v,[s("[selectors-4] Rename :matches() to :is() · Issue #3258 · w3c/csswg-drafts"),a(n)]),s(")，因为"),h,s("的名称更简短，且其语义正好和"),m,s("相反。")]),b,e("p",null,[s("规范将 "),k,s(" 和 "),g,s(" 定义为接受一个"),e("a",_,[s("可容错选择器列表"),a(n)])]),f,e("p",null,[s("早前这并没有被浏览器所支持，最近查看MDN发现很多浏览器已经支持了~（"),e("a",x,[s(":has() - CSS（层叠样式表） | MDN"),a(n)]),s("）")]),y])}const I=o(p,[["render",w],["__file","逻辑组合伪类.html.vue"]]);export{I as default};
