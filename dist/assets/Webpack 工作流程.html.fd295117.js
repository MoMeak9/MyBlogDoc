import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as t,e as r}from"./app.d7b34baa.js";const n={},s=r('<h1 id="webpack-工作流程" tabindex="-1"><a class="header-anchor" href="#webpack-工作流程" aria-hidden="true">#</a> Webpack 工作流程</h1><p>Webpack 最核心的功能依然是：<strong>At its core, webpack is a static module bundler for modern</strong> <strong>JavaScript</strong> <strong>applications</strong>，也就是所谓的<strong>静态模块打包能力</strong>。</p><p><strong>一是使用适当 Loader 将任意类型文件转译为 JavaScript 代码</strong>，例如将 CSS 代码转译为 JS 字符串，将多媒体文件转译为 Base64 代码等；</p><p><strong>二是将这些经过 Loader 处理的文件资源合并、打包成向下兼容的产物文件。</strong></p><p>总体逻辑步骤：</p><img src="https://cdn.yihuiblog.top/images/202208191658874.png" alt="image-20220819165737954" style="zoom:67%;"><p>为了实现这些功能，Webpack 底层的工作流程大致可以总结为这么几个阶段：</p><p>简化步骤：</p><img src="https://cdn.yihuiblog.top/images/202208191657288.webp" alt="image.png" style="zoom:67%;"><ol><li><p><strong>初始化阶段</strong>：修整配置参数，创建 Compiler、Compilation 等基础对象，并初始化插件及若干内置工厂、工具类，并最终根据 <code>entry</code> 配置，找到所有入口模块；</p><blockquote><p>「<strong>初始化</strong>」的重点是根据用户配置设置好构建环境；</p></blockquote></li><li><p><strong>构建阶段</strong>：从 <code>entry</code> 文件开始，调用 <code>loader</code> 将模块转译为 JavaScript 代码，调用 <strong>Acorn</strong> 将代码转换为 AST 结构，遍历 AST 从中找出该模块依赖的模块；之后 <strong>递归</strong> 遍历所有依赖模块，找出依赖的依赖，直至遍历所有项目资源后，构建出完整的<strong>模块依赖关系图</strong>；</p><blockquote><p>「<strong>构建阶段</strong>」则重在解读文件输入与文件依赖关系；</p></blockquote></li><li><p><strong>生成阶段</strong>：根据 <code>entry</code> 配置，将模块组装为一个个 Chunk 对象，之后调用一系列 Template 工厂类翻译 Chunk 代码并封装为 Asset，最后写出到文件系统。</p><blockquote><p>最后在「<strong>生成阶段</strong>」按规则组织、包装模块，并翻译为适合能够直接运行的产物包;</p></blockquote></li></ol><h3 id="初始化阶段" tabindex="-1"><a class="header-anchor" href="#初始化阶段" aria-hidden="true">#</a> 初始化阶段：</h3><ul><li><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数；</li><li>**创建编译器对象 **：用上一步得到的参数创建 Compiler 对象；</li><li><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等；</li><li><strong>开始编译</strong>：执行 compiler 对象的 run 方法，创建 Compilation 对象；</li><li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件，调用 <code>compilation.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象。</li></ul><p><img src="https://cdn.yihuiblog.top/images/202208191709506.webp" alt="image.png"></p><h3 id="构建阶段" tabindex="-1"><a class="header-anchor" href="#构建阶段" aria-hidden="true">#</a> 构建阶段：</h3><ul><li><strong>编译模块(make)</strong>：从 <code>entry</code> 文件开始，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解析器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 <strong>递归</strong> 处理这些依赖模块，直到所有入口依赖的文件都经过了本步骤的处理；</li><li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的<code>依赖关系图</code>。</li></ul><p><img src="https://cdn.yihuiblog.top/images/202208191712130.webp" alt="img"></p><h3 id="封装生成阶段" tabindex="-1"><a class="header-anchor" href="#封装生成阶段" aria-hidden="true">#</a> 封装生成阶段：</h3><ul><li><strong>合并(seal)</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>；</li><li><strong>优化(optimization)</strong>：对上述 <code>Chunk</code> 施加一系列优化操作，包括：tree-shaking、terser、scope-hoisting、压缩、Code Split 等；</li><li><strong>写入文件系统(emitAssets)</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><img src="https://cdn.yihuiblog.top/images/202208191716020.webp" alt="image.png" style="zoom:67%;">',19),i=[s];function a(c,l){return e(),t("div",null,i)}const d=o(n,[["render",a],["__file","Webpack 工作流程.html.vue"]]);export{d as default};
