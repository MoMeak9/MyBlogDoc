import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as n,a as t,b as o,d,e as c,r as i}from"./app.d7b34baa.js";const r={},p=c(`<h1 id="前端路由-hash-与-history-差异" tabindex="-1"><a class="header-anchor" href="#前端路由-hash-与-history-差异" aria-hidden="true">#</a> 前端路由 hash 与 history 差异</h1><h2 id="储备知识" tabindex="-1"><a class="header-anchor" href="#储备知识" aria-hidden="true">#</a> 储备知识</h2><h3 id="spa" tabindex="-1"><a class="header-anchor" href="#spa" aria-hidden="true">#</a> SPA</h3><p><strong>SPA</strong>，即<strong>单页面应用</strong>(Single Page Application)。所谓单页 <code>Web</code> 应用，就是只有一张 <code>Web</code> 页面的应用。单页应用程序 (SPA) 是加载单个 <code>HTML</code> 页面并在<strong>用户与应用程序交互时</strong>动态更新该页面的 <code>Web</code> 应用程序。浏览器一开始会加载必需的 <code>HTML</code> 、 <code>CSS</code> 和 <code>JavaScript</code> ，所有的操作都在这张页面上完成，都由 <code>JavaScript</code> 来控制。</p><h3 id="网页url组成部分" tabindex="-1"><a class="header-anchor" href="#网页url组成部分" aria-hidden="true">#</a> 网页URL组成部分</h3><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>location.protocal</td><td>协议</td></tr><tr><td>location.hostname</td><td>主机名</td></tr><tr><td>location.host</td><td>主机</td></tr><tr><td>location.port</td><td>端口号</td></tr><tr><td>location.patchname</td><td>访问页面</td></tr><tr><td>location.search</td><td>搜索内容</td></tr><tr><td>location.hash</td><td>哈希值</td></tr></tbody></table><h3 id="history-api" tabindex="-1"><a class="header-anchor" href="#history-api" aria-hidden="true">#</a> history API</h3><p><code>HTML5</code> 新增的 <code>history API</code></p><table><thead><tr><th>API</th><th>定义</th></tr></thead><tbody><tr><td>history.<strong>pushState</strong>(data, title [, url])</td><td>pushState主要用于<strong>往历史记录堆栈顶部添加一条记录</strong>。各参数解析如下：<strong>①data</strong>会在onpopstate事件触发时作为参数传递过去；<strong>②title</strong>为页面标题，当前所有浏览器都会忽略此参数；③<strong>url</strong>为页面地址，可选，缺少时表示为当前页地址</td></tr><tr><td>history.<strong>replaceState</strong>(data, title [, url])</td><td>更改当前的历史记录，参数同上； 上面的pushState是添加，这个更改</td></tr><tr><td>history.<strong>state</strong></td><td>用于存储以上方法的data数据，不同浏览器的读写权限不一样</td></tr><tr><td>window.<strong>onpopstate</strong></td><td>每当激活同一文档中不同的历史记录条目时，<code>popstate</code> 事件就会在对应的 <code>window</code> 对象上触发。</td></tr></tbody></table><blockquote><p>调用 <code>history.pushState()</code> 或者 <code>history.replaceState()</code> 不会触发 <code>popstate</code> 事件。<code>popstate</code> 事件只会在浏览器某些行为下触发，比如点击后退按钮（或者在 JavaScript 中调用 <code>history.back()</code> 方法）。即，在同一文档的两个历史记录条目之间导航会触发该事件。</p></blockquote><h2 id="hash模式" tabindex="-1"><a class="header-anchor" href="#hash模式" aria-hidden="true">#</a> hash模式</h2><p><strong>工具人：</strong></p><ul><li><p><code>window.location.hash</code></p></li><li><p><code>onhashchange()</code>事件</p></li></ul><p><strong>简介：</strong></p><p>hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="">www.abc.com/#/mock</a>，它的hash值就是<code>#/mock</code>，hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。。</p><p><strong>特点：</strong></p><ul><li>hash值会出现在URL里面，但是不会出现在HTTP请求中。所以改变hash值，不会重新加载页面。</li><li>这种模式的浏览器支持度（兼容性）好，支持IE。hash路由被称为是前端路由，已经成为SPA的标配。</li><li>所有页面的跳转都是在客户端进行操作。因此，并不算是一次 <code>http</code> 请求，所以这种模式不利于 <code>SEO</code> 优化。<code>hash</code> 只能修改 <code>#</code> 后面的部分，所以只能跳转到与当前 <code>url</code> 同文档的 <code>url</code> 。</li></ul><p><strong>原理：</strong></p><p>hash模式的主要原理就是使用<code>window.location.hash</code>属性及<code>window.onhashchange()</code>事件：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 设置 url 的 hash，会在当前url后加上&#39;#aabb&#39;</span>
window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash<span class="token operator">=</span><span class="token string">&#39;aabb&#39;</span><span class="token punctuation">;</span>

window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;hashchange&#39;</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 监听hash变化</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>onhashchange()</code>事件，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器浏览记录记录下来，这样浏览器就能实现页面的前进和后退。</p><p>注意：页面第一次加载完不会触发 hashchange，因而在具体实践中通过监听load事件来获取hash值，再将视图渲染成对应的内容。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;DOMContentLoaded&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="触发情况" tabindex="-1"><a class="header-anchor" href="#触发情况" aria-hidden="true">#</a> 触发情况</h3><ol><li>浏览器地址栏散列值的变化（包括浏览器的前进、后退），从而使得<code>window.location.hash</code>值的变化，触发<code>onhashchange</code>事件（包括对<code>window.location.hash</code>的直接赋值）</li><li><strong>输入浏览器地址栏中URL包含哈希值</strong>，如 <code>http://www.google.com/#/home</code>，这时按下输入，浏览器发送<code>http://www.baidu.com/</code>请求至服务器，请求完毕之后设置散列值为<code>#/home</code>，进而触发onhashchange事</li><li><strong>修改浏览器地址栏URL的哈希部分</strong>，这时按下回车，浏览器不会发送任何请求至服务器，而是只设置散列值新修改的哈希值，并触发onhashchange事件</li><li><strong>html中<code>&lt;a&gt;</code>标签的属性 href 设置为页面的元素id</strong>，如 <code>#top</code>实现跳转，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 <code>window.location.hash</code> 属性，地址栏中的哈希值也会发生改变，并触发<code>onhashchange</code>事件；</li></ol><h2 id="history-模式" tabindex="-1"><a class="header-anchor" href="#history-模式" aria-hidden="true">#</a> history 模式</h2><p><strong>工具人：</strong></p><ul><li><code>window.history.state</code></li><li><code>onpopstate()</code>事件</li></ul><p>操作历史记录：</p><ul><li><p><code>history.pushState </code> 往历史记录堆栈顶部添加一条记录</p></li><li><p><code>history.replaceState</code> 更改当前的历史记录</p></li></ul><p><strong>概述：</strong></p><p><code>history API</code> 是 <code>H5</code> 提供的新特性，允许开发者<strong>直接更改前端路由</strong>，即更新浏览器 <code>URL</code> 地址而<strong>不重新发起请求</strong>。</p><p><code>window.history</code> 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。 History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p><p><strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p><ul><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li><li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><h3 id="触发情况-1" tabindex="-1"><a class="header-anchor" href="#触发情况-1" aria-hidden="true">#</a> 触发情况</h3><ul><li><p>仅仅调用<code>pushState()</code>方法或<code>replaceState()</code>方法 ，并不会触发该事件。只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用history.back()、history.forward()、history.go()方法时才会触发。</p><p>实际上进行的router.push()操作，是使用pushState()创建新历史记录后（路由前进），直接改变路由内的视图，同时达到对历史纪录的存储而不对服务器进行请求。而后退的时候触发会onpopstate()事件，通过监听此事件改变视图内容。</p></li><li><p>事件只针对同一个文档，如果加载不同的文档，该事件也不会触发。</p></li><li><p>页面第一次加载的时候，浏览器不会触发popstate事件。</p></li></ul><p>监听<code>popstate</code>的回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;popstate&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//e.state 相当于 history.state</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="history-pushstate-和-history-push-区别" tabindex="-1"><a class="header-anchor" href="#history-pushstate-和-history-push-区别" aria-hidden="true">#</a> history.pushState 和 history.push 区别</h4><ul><li>history.pushState () 不会向服务器发送请求，只会改变浏览器地址栏中的地址，并且把地址记录到历史记录中，所以可以实现客户端路由 另外，IE10 以后才支持。</li><li>history.push () 路径发生变化，需要向服务器发送请求。</li></ul><h3 id="缺陷和补救" tabindex="-1"><a class="header-anchor" href="#缺陷和补救" aria-hidden="true">#</a> 缺陷和补救</h3><p>history 致命的缺点就是当改变页面地址后，在服务器没有进行额外配置的情况下，强制刷新浏览器时会报错，因为刷新是拿当前地址去请求服务器的，会出现 404 的情况。</p><p>对于 <code>hash</code> 模式来说， 它虽然看着是改变了 <code>url</code> ，但不会被包括在 <code>http</code> 请求中。所以，<strong>它算是被用来指导浏览器的动作，并不影响服务器端</strong>。因此，改变 <code>hash</code> 并没有真正地改变 <code>url</code> ，所以页面路径还是之前的路径， <code>nginx</code> 也就不会拦截。</p><p>对于index.html存在服务器本地的Nginx的常用配置，实际上在VueRouter的官方文档中也提到了, 只需要配置一个<u>location try_files</u>默认指向index.html即可。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>location / {
  add_header Cache-Control &#39;no-store, no-cache&#39;; // 设置不缓存
  try_files $uri $uri/ /index.html;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于index.html存在远程地址，例如上传到了OSS或者CDN上的远程地址，可以使用以下方法配置：</p><ul><li><p>基础访问地址<a href="">xxxxxx/text/</a></p></li><li><p>真正的index.html位置<a href="">xxxxx/oss.b.com/project/index</a></p></li></ul><p>即对真实服务器地址和访问路径分别进行了代理和重写</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>location ^~ /test/ {
    add_header Cache-Control &#39;no-store, no-cache&#39;; // 设置不缓存
    rewrite ^ /project/index.html break;
    proxy_pass https://oss.b.com;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,50),l=t("p",null,"参考：",-1),h={href:"https://blog.csdn.net/qq_36671474/article/details/79975846",target:"_blank",rel:"noopener noreferrer"};function u(g,v){const a=i("ExternalLinkIcon");return s(),n("div",null,[p,t("blockquote",null,[l,t("p",null,[t("a",h,[o("hash和hashchange事件"),d(a)])])])])}const k=e(r,[["render",u],["__file","前端路由 hash 与 history 差异.html.vue"]]);export{k as default};
