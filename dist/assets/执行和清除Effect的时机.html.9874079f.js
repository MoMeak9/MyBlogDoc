import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as p,c,a as n,b as s,d as t,e as o,r as i}from"./app.d7b34baa.js";const u={},l=n("h1",{id:"执行和清除effect的时机",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#执行和清除effect的时机","aria-hidden":"true"},"#"),s(" 执行和清除Effect的时机")],-1),d=n("p",null,"React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。众所周知，effect 在每次渲染的时候都会执行，而这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除，因为这有助于避免Bug，这是React的默认行为。",-1),r=n("h2",{id:"原因-为什么每次更新的时候都要运行-effect",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#原因-为什么每次更新的时候都要运行-effect","aria-hidden":"true"},"#"),s(" 原因：为什么每次更新的时候都要运行 Effect")],-1),k=n("p",null,"如果你已经习惯了使用 class，那么你或许会疑惑为什么 effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。",-1),m={href:"https://zh-hans.reactjs.org/docs/hooks-effect.html#example-using-classes-1",target:"_blank",rel:"noopener noreferrer"},f=o(`<div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>但是当组件已经显示在屏幕上时，<code>friend</code> prop 发生变化时会发生什么？</strong> 我们的组件将继续展示原来的好友状态。这是一个 bug。而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。</p><p>在 class 组件中，我们需要添加 <code>componentDidUpdate</code> 来解决这个问题：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取消订阅之前的 friend.id</span>
    ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
      prevProps<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 订阅新的 friend.id</span>
    ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>handleStatusChange
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而useEffect它并不会受到此 bug 影响，并不需要特定的代码来处理更新逻辑，因为 <code>useEffect</code> <em>默认</em>就会处理。<strong>它会在调用一个新的 effect 之前对前一个 effect 进行清理。</strong></p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// Mount with { friend: { id: 100 } } props</span>
ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 运行第一个 effect</span>

<span class="token comment">// Update with { friend: { id: 200 } } props</span>
ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除上一个 effect</span>
ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 运行下一个 effect</span>

<span class="token comment">// Update with { friend: { id: 300 } } props</span>
ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除上一个 effect</span>
ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 运行下一个 effect</span>

<span class="token comment">// Unmount</span>
ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除最后一个 effect</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug。</p><h2 id="性能-通过跳过-effect-进行性能优化" tabindex="-1"><a class="header-anchor" href="#性能-通过跳过-effect-进行性能优化" aria-hidden="true">#</a> 性能：通过跳过 Effect 进行性能优化</h2><p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 <code>componentDidUpdate</code> 中添加对 <code>prevProps</code> 或 <code>prevState</code> 的比较逻辑解决：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevState<span class="token punctuation">.</span>count <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是很常见的需求，所以<strong>它被内置到了 <code>useEffect</code> 的 Hook API 中</strong>。如果某些特定值在两次重渲染之间没有发生变化（浅比较），你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅在 count 更改时更新</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12),v=n("code",null,"[]",-1),h=n("code",null,"[]",-1),b=n("code",null,"componentDidMount",-1),g=n("code",null,"componentWillUnmount",-1),_={href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies",target:"_blank",rel:"noopener noreferrer"},x={href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often",target:"_blank",rel:"noopener noreferrer"},S=n("code",null,"useEffect",-1);function C(F,P){const a=i("ExternalLinkIcon");return p(),c("div",null,[l,d,r,k,n("p",null,[s("例如订阅好友在线状态的"),n("a",m,[s("组件"),t(a)]),s("：")]),f,n("blockquote",null,[n("p",null,[s("第二个参数如果你传入了一个空数组（"),v,s("），effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入 "),h,s(" 作为第二个参数更接近大家更熟悉的 "),b,s(" 和 "),g,s(" 思维模式，但我们有"),n("a",_,[s("更好的"),t(a)]),n("a",x,[s("方式"),t(a)]),s("来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 "),S,s("，因此会使得额外操作很方便。")])])])}const I=e(u,[["render",C],["__file","执行和清除Effect的时机.html.vue"]]);export{I as default};
