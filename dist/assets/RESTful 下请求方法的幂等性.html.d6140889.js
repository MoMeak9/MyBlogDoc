import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as d,e as a}from"./app.d7b34baa.js";const r={},h=a(`<h1 id="restful-下请求方法的幂等性" tabindex="-1"><a class="header-anchor" href="#restful-下请求方法的幂等性" aria-hidden="true">#</a> RESTful 下请求方法的幂等性</h1><h2 id="概念阐述" tabindex="-1"><a class="header-anchor" href="#概念阐述" aria-hidden="true">#</a> 概念阐述</h2><p>一个 HTTP 方法是<strong>幂等</strong>的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的 safe 方法也都是幂等的。</p><p>幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。</p><h3 id="safe-安全" tabindex="-1"><a class="header-anchor" href="#safe-安全" aria-hidden="true">#</a> Safe（安全）</h3><p>如果说一个 HTTP 方法是<code>安全</code>的，是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：<code>GET</code>，<code>HEAD</code> 和 <code>OPTIONS</code>。所有安全的方法都是idempotent的，但并非所有幂等方法都是安全的，例如，<code>PUT</code> 和 <code>DELETE</code> 都是幂等的，但不是安全的。</p><h3 id="分析图表" tabindex="-1"><a class="header-anchor" href="#分析图表" aria-hidden="true">#</a> 分析图表</h3><table><thead><tr><th>HTTP Method</th><th>Idempotent 幂等</th><th>Safe 安全</th></tr></thead><tbody><tr><td>OPTIONS</td><td>✔️</td><td>✔️</td></tr><tr><td>HEAD</td><td>✔️</td><td>✔️</td></tr><tr><td>GET</td><td>✔️</td><td>✔️</td></tr><tr><td>POST</td><td><strong>❌</strong></td><td>❌</td></tr><tr><td>PUT</td><td>✔️</td><td>❌</td></tr><tr><td>PATCH</td><td><strong>❌</strong></td><td>❌</td></tr><tr><td>DELETE</td><td>✔️</td><td>❌</td></tr></tbody></table><h2 id="为什么put和delete是幂等-而patch则是非幂等的" tabindex="-1"><a class="header-anchor" href="#为什么put和delete是幂等-而patch则是非幂等的" aria-hidden="true">#</a> 为什么put和delete是幂等，而patch则是非幂等的？</h2><h3 id="put【幂等】" tabindex="-1"><a class="header-anchor" href="#put【幂等】" aria-hidden="true">#</a> PUT【幂等】</h3><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code> PUT /user/1   #修改id为 1 的 user 的全部信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于更新资源，没有的话则执行创建操作。每次执行请求时都会先判断一下序号为1的User信息是否存在，不存在则创建，否则视为更新。很显然，请求携带的数据每次都是一样的，所以不论请求多少次，最终的结果都是后台存在这么一个资源（同内容覆盖式的更新或创建资源）。</p><h3 id="patch【非幂等】" tabindex="-1"><a class="header-anchor" href="#patch【非幂等】" aria-hidden="true">#</a> PATCH【非幂等】</h3><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code> PATCH /user/1/house/3   #给id为1的user增加3个大房子
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于更新资源，即数据实体的一部分属性（局部修改），该数据必然存在，否则失去更新意义。每次执行请求时都会先判断一下序号为1的User信息是否存在，存在则更新数据信息。根据URL，我们需要处理的是将User的house属性增加3，很显然，多次请求时会重复增加，而无法保持为一个确定的值。PATCH 处于不可控的地位，所以说 PUT 方法是幂等的，而 PATCH 方法不是幂等的。</p>`,15),s=[h];function i(n,c){return e(),d("div",null,s)}const u=t(r,[["render",i],["__file","RESTful 下请求方法的幂等性.html.vue"]]);export{u as default};
