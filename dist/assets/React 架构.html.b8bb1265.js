import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c,a as e,b as n,d as a,e as o,r as l}from"./app.d7b34baa.js";const i={},p=o('<h1 id="react-架构" tabindex="-1"><a class="header-anchor" href="#react-架构" aria-hidden="true">#</a> React 架构</h1><p>因为v15不能满足快速响应的理念（或者说原先的设计缺陷），<code>React</code>从v15升级到v16后重构了整个架构。</p><h2 id="react-15-架构" tabindex="-1"><a class="header-anchor" href="#react-15-架构" aria-hidden="true">#</a> React 15 架构</h2><p>React15架构可以分为两层：</p><ul><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 id="reconciler-协调器" tabindex="-1"><a class="header-anchor" href="#reconciler-协调器" aria-hidden="true">#</a> Reconciler（协调器）</h3><p>我们知道，在<code>React</code>中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等API触发更新。</p><p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作（对比并协调渲染器更新）：</p><ol><li><p>调用函数组件、或class组件的<code>render</code>方法，将返回的 JSX 转化为虚拟 DOM</p></li><li><p>将虚拟DOM和上次更新时的虚拟DOM对比</p></li><li><p>通过对比找出本次更新中变化的虚拟DOM</p></li><li><p>通知<strong>Renderer</strong>将变化的虚拟DOM渲染到页面上</p></li></ol><blockquote><p><strong>官方描述：</strong></p><p>“stack” reconciler 是 React 15 及更早的解决方案，React已经停止了对它的使用。</p></blockquote><h3 id="renderer-渲染器" tabindex="-1"><a class="header-anchor" href="#renderer-渲染器" aria-hidden="true">#</a> Renderer（渲染器）</h3>',11),d=e("code",null,"React",-1),u=e("strong",null,"Renderer",-1),h=e("strong",null,"Renderer",-1),k={href:"https://www.npmjs.com/package/react-dom",target:"_blank",rel:"noopener noreferrer"},_=e("blockquote",null,[e("p",null,[e("strong",null,"渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。")])],-1),g=e("p",null,"除此之外，还有：",-1),m={href:"https://www.npmjs.com/package/react-native",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.npmjs.com/package/react-test-renderer",target:"_blank",rel:"noopener noreferrer"},R={href:"https://www.npmjs.com/package/react-art",target:"_blank",rel:"noopener noreferrer"},f=o('<p>在每次更新发生时，<strong>Renderer</strong>接到<strong>Reconciler</strong>通知，将变化的组件渲染在当前宿主环境。</p><h3 id="react15架构的缺点" tabindex="-1"><a class="header-anchor" href="#react15架构的缺点" aria-hidden="true">#</a> React15架构的缺点</h3><p>在Reconciler中，mount的组件会调用mountComponent (opens new window)，update的组件会调用updateComponent (opens new window)。这两个方法都会递归更新子组件。</p><h4 id="递归更新的缺点" tabindex="-1"><a class="header-anchor" href="#递归更新的缺点" aria-hidden="true">#</a> 递归更新的缺点</h4><p>由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。</p><p><img src="https://cdn.yihuiblog.top/images/202208241736854.png" alt="更新流程"></p><p>而v15使用同步更新，<strong>Reconciler</strong>和<strong>Renderer</strong>是交替工作的，当第一个<code>li</code>在页面上已经变化后，第二个<code>li</code>再进入<strong>Reconciler</strong>。由于整个过程都是同步的，所以在用户看来所有DOM是同时更新的，但是这样也就导致了对多个节点同步更新的卡顿问题，因为他需要“全部”更新完成后交付给用户，只有当时间比较短的时候才会使用户感觉是同步更新的。</p><p>让我们模拟一下，如果中途中断更新会怎么样？</p><blockquote><p>实际中v15并不能直接中断，而这也是导致卡顿的矛盾点</p></blockquote><p><img src="https://cdn.yihuiblog.top/images/202208241738053.png" alt="中断更新流程"></p><p>当第一个<code>li</code>完成更新时中断更新，即步骤3完成后中断更新，此时后面的步骤都还未执行。</p><p>用户本来期望<code>123</code>变为<code>246</code>。实际却看见更新不完全的DOM！（即<code>223</code>）</p><p>基于这个原因，<code>React</code>决定重写整个架构。</p><h2 id="react-16-架构" tabindex="-1"><a class="header-anchor" href="#react-16-架构" aria-hidden="true">#</a> React 16 架构</h2><p>React16架构可以分为三层：</p><ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 id="scheduler-调度器" tabindex="-1"><a class="header-anchor" href="#scheduler-调度器" aria-hidden="true">#</a> Scheduler（调度器）⭐</h3><p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>',18),w={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback",target:"_blank",rel:"noopener noreferrer"},v=e("ul",null,[e("li",null,"服务器兼容性"),e("li",null,[n("触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的"),e("code",null,"requestIdleCallback"),n("触发的频率会变得很低")])],-1),x=e("blockquote",null,[e("p",null,"又再次证明了，前端工程师的技术升级靠的是客户的浏览器的升级")],-1),y=e("code",null,"React",-1),D=e("code",null,"requestIdleCallback ",-1),M=e("strong",null,"Scheduler",-1),O=e("strong",null,"Scheduler",-1),I={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md",target:"_blank",rel:"noopener noreferrer"},S=e("code",null,"React",-1),q=o(`<h3 id="reconciler-协调器-变动" tabindex="-1"><a class="header-anchor" href="#reconciler-协调器-变动" aria-hidden="true">#</a> Reconciler（协调器）变动</h3><p>更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/** <span class="token keyword">@noinline</span> */</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Perform work until Scheduler asks us to yield</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在React16中，<strong>Reconciler</strong>与<strong>Renderer</strong>不再是交替工作。当<strong>Scheduler</strong>将任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b0000000000010</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b0000000000100</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b0000000000110</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b0000000001000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个<strong>Scheduler</strong>与<strong>Reconciler</strong>的工作都在内存中进行。只有当所有组件都完成<strong>Reconciler</strong>的工作，才会统一交给<strong>Renderer</strong>。</p>`,6),j=o("<p><strong>官方描述：</strong></p><p>“fiber” reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。</p><p>它的主要目标是：</p><ul><li>能够把可中断的任务切片处理。</li><li>能够调整优先级，重置并复用任务。</li><li>能够在父元素与子元素之间交错处理，以支持 React 中的布局。</li><li>能够在 <code>render()</code> 中返回多个元素。</li><li>更好地支持错误边界。</li></ul>",4),C={href:"https://github.com/acdlite/react-fiber-architecture",target:"_blank",rel:"noopener noreferrer"},P={href:"https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e",target:"_blank",rel:"noopener noreferrer"},A=e("h3",{id:"renderer-渲染器-变动",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#renderer-渲染器-变动","aria-hidden":"true"},"#"),n(" Renderer（渲染器）变动")],-1),E=e("p",null,"在React16架构中整个更新流程为：",-1),N=e("p",null,[e("img",{src:"https://cdn.yihuiblog.top/images/202208251059950.png",alt:"更新流程"})],-1),V=e("p",null,"其中红框中的步骤随时可能由于以下原因被中断：",-1),L=e("ul",null,[e("li",null,"有其他更高优任务需要先更新"),e("li",null,"当前帧没有剩余时间")],-1),U=e("p",null,"由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。所以，实际上真实DOM更新还是同步进行的，但对虚拟DOM的检查和更新是异步可中断的，当没有其他变化的时候，Reconciler将完整的可交付虚拟DOM交给渲染器统一渲染。",-1),B=e("strong",null,"Scheduler",-1),W=e("strong",null,"Reconciler",-1),z=e("code",null,"React",-1),F={href:"https://www.npmjs.com/package/react-reconciler",target:"_blank",rel:"noopener noreferrer"},J=e("p",null,"还有就是，从红色框到渲染器的部分还依赖于双缓存的实现，以保证用户无法明显感知这一更新过程。",-1);function T(Y,G){const s=l("ExternalLinkIcon");return r(),c("div",null,[p,e("p",null,[n("由于"),d,n("支持跨平台，所以不同平台有不同的"),u,n("。我们前端最熟悉的是负责在浏览器环境渲染的"),h,n(" —— "),e("a",k,[n("ReactDOM"),a(s)]),n(" （接受协调的工具人）")]),_,g,e("ul",null,[e("li",null,[e("a",m,[n("ReactNative (opens new window)"),a(s)]),n("渲染器，渲染App原生组件")]),e("li",null,[e("a",b,[n("ReactTest (opens new window)"),a(s)]),n("渲染器，渲染出纯Js对象用于测试")]),e("li",null,[e("a",R,[n("ReactArt (opens new window)"),a(s)]),n("渲染器，渲染到Canvas, SVG 或 VML (IE8)")])]),f,e("p",null,[n("其实部分浏览器已经实现了这个API，这就是"),e("a",w,[n("requestIdleCallback"),a(s)]),n("，但由于以下缺陷，React放弃使用：")]),v,x,e("p",null,[n("基于以上原因，"),y,n("实现了功能更完备的"),D,n(" polyfill（腻子脚本），这就是"),M,n("。除了在空闲时触发回调的功能外，"),O,n("还提供了多种调度优先级供任务设置。"),e("a",I,[n("Scheduler"),a(s)]),n("是独立于"),S,n("的库。")]),q,e("blockquote",null,[j,e("p",null,[n("你可以在"),e("a",C,[n("这里"),a(s)]),n("和"),e("a",P,[n("这里"),a(s)]),n("，深入了解 React Fiber 架构。虽然这已经在 React 16 中启用了，但是 async 特性还没有默认开启。")])]),A,E,N,V,L,U,e("blockquote",null,[e("p",null,[n("实际上，由于"),B,n("和"),W,n("都是平台无关的，所以"),z,n("为他们单独发了一个包"),e("a",F,[n("react-Reconciler"),a(s)])]),J])])}const K=t(i,[["render",T],["__file","React 架构.html.vue"]]);export{K as default};
