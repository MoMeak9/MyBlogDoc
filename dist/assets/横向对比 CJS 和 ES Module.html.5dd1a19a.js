import{_ as r}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as d,c as t,a as e,b as o,d as a,e as s,r as l}from"./app.d7b34baa.js";const c={},p=s('<h1 id="横向对比-cjs-和-es-module" tabindex="-1"><a class="header-anchor" href="#横向对比-cjs-和-es-module" aria-hidden="true">#</a> 横向对比 CJS 和 ES Module</h1><h2 id="模块化-🖥️" tabindex="-1"><a class="header-anchor" href="#模块化-🖥️" aria-hidden="true">#</a> 模块化 🖥️</h2><h3 id="什么是模块化开发" tabindex="-1"><a class="header-anchor" href="#什么是模块化开发" aria-hidden="true">#</a> 什么是模块化开发</h3><p>模块化开发最终的目的是将程序<strong>划分成一个个小的结构</strong>。在这个结构中编写属于<strong>自己的逻辑代码</strong>，有自己的作用域，不会影响到其他的结构。结构可以将自己希望暴露的<strong>变量、函数、对象等导出</strong>给其结构使用。也可以通过某种方式，导入另外结构中的<strong>变量、函数、对象</strong>等。</p><p>上面说提到的结构，就是模块，按照这种结构划分开发程序的过程，就是模块化开发的过程。</p><h2 id="commonjs-🦜" tabindex="-1"><a class="header-anchor" href="#commonjs-🦜" aria-hidden="true">#</a> CommonJS 🦜</h2>',6),i={href:"https://zhaoda.net/webpack-handbook/commonjs.html",target:"_blank",rel:"noopener noreferrer"},u=s(`<blockquote><p>CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。</p><p>这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS。</p></blockquote><h3 id="通过-exports-导出模块内容" tabindex="-1"><a class="header-anchor" href="#通过-exports-导出模块内容" aria-hidden="true">#</a> 通过 exports 导出模块内容</h3><p>exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出；</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// bar.js</span>
exports<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">&#39;age&#39;</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>sayHello <span class="token operator">=</span> <span class="token string">&#39;sayHello&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个文件中可以导入：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// main.js</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这行完成了什么操作呢？</p><p>意味着main中的bar变量等于exports对象，也就是require通过各种查找方式，最终找到了exports这个对象，并且将这个exports对象赋值给了bar变量，bar变量就是exports对象了。</p><p>需要注意 <code>exports</code> 不能被赋值，可以理解为在模块开始前<code>exports = module.exports</code>， 因为赋值之后<code>exports</code>失去了 对<code>module.exports</code>的引用，成为了一个模块内的局部变量。</p><h3 id="浅拷贝-引用赋值" tabindex="-1"><a class="header-anchor" href="#浅拷贝-引用赋值" aria-hidden="true">#</a> 浅拷贝（引用赋值）</h3><p>实际上有别于ES Module</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// main.js</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>bar对象是exports对象的浅拷贝（引用赋值）</strong>，浅拷贝的本质就是一种引用的赋值而已，是不是想到了什么问题？对，exports对象中的属性修改，所引用的bar对象内容也会被修改。</p><h3 id="module-exports-咋来的" tabindex="-1"><a class="header-anchor" href="#module-exports-咋来的" aria-hidden="true">#</a> module.exports 咋来的？</h3><p><strong>在Node中真正用于导出的其实根本不是exports，而是module.exports；Node内部提供一个<code>Module</code>构建函数。所有模块都是<code>Module</code>的实例。</strong> CommonJS中是没有module.exports的概念的。</p><h2 id="node-js模块加载过程-✨" tabindex="-1"><a class="header-anchor" href="#node-js模块加载过程-✨" aria-hidden="true">#</a> Node.js模块加载过程 ✨</h2><p>模块在被第一次引入时，模块中的js代码会被运行一次，模块被多次引入时，会缓存，<strong>最终只加载（运行）一次</strong>，这是因为每个模块对象 <code>module</code> 都有一个属性：<code>loaded</code>。<code>loaded</code> 为<code>false</code> 表示还没有加载，为<code>true</code>表示已经加载，如果有循环引入，那么加载顺序是采取深度优先算法。</p>`,17),m=e("p",null,[e("strong",null,"module属性和方法：")],-1),h={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#moduleid",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#modulefilename",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#moduleloaded",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#moduleparent",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#modulechildren",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#moduleexports",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#exports-%E7%9A%84%E5%88%AB%E5%90%8D",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.bookstack.cn/read/nodejs-api-doc-cn/modules-module.md#modulerequireid",target:"_blank",rel:"noopener noreferrer"},j=s('<h2 id="commonjs规范缺点-🪄" tabindex="-1"><a class="header-anchor" href="#commonjs规范缺点-🪄" aria-hidden="true">#</a> CommonJS规范缺点 🪄</h2><p><strong>CommonJS同步加载模块是双刃剑</strong></p><p>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行。这个在服务端不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快。但是当用于浏览器的时候，因为浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行（全量加载）。而且采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作，所以在浏览器中，我们通常不使用CommonJS规范；</p><p><strong>早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD</strong>。目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者 ES Module代码的转换；</p><h2 id="其他模块规范-♣️" tabindex="-1"><a class="header-anchor" href="#其他模块规范-♣️" aria-hidden="true">#</a> 其他模块规范 ♣️</h2><h4 id="amd规范" tabindex="-1"><a class="header-anchor" href="#amd规范" aria-hidden="true">#</a> AMD规范</h4><p>AMD规范就是其中比较著名一个，<strong>全称是Asynchronous Module Definition，即异步模块加载机制</strong>。 从它的规范描述页面看，AMD很短也很简单，但它却完整描述了模块的定义，依赖关系，引用关系以及加载机制，是异步加载模块。</p><h4 id="cmd规范" tabindex="-1"><a class="header-anchor" href="#cmd规范" aria-hidden="true">#</a> CMD规范</h4><p>CMD（Common Module Definition）是国内大牛玉伯在开发SeaJS的时候提出来的，<strong>属于CommonJS的一种规范，根据浏览器的异步环境做了自己的实现</strong>。 它和AMD 很相似，尽量保持简单，并与CommonJS 和Node.js 的Modules 规范保持了很大的兼容性。</p><h2 id="结语-📓" tabindex="-1"><a class="header-anchor" href="#结语-📓" aria-hidden="true">#</a> 结语 📓</h2><p>文章内容是根据<code>codewhy</code>老师的<code>《深入Node.js技术栈》</code>课程整理的笔记，并补充了其他的课外内容，其中还涵盖了<code>《深入浅出Node.js》</code>的内容。下篇会更新ES Module，之后横向比较一下两者，这也是面试的时候经常被问到的，例如什么是模块化，CJS和ES Module的区别等等。</p>',11);function S(w,M){const n=l("ExternalLinkIcon");return d(),t("div",null,[p,e("p",null,[e("a",i,[o("CommonJS"),a(n)]),o("是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了 体现它的广泛性，修改为CommonJS，通常简称CJS。")]),u,e("blockquote",null,[m,e("ul",null,[e("li",null,[e("a",h,[o("module.id"),a(n)])]),e("li",null,[e("a",k,[o("module.filename"),a(n)])]),e("li",null,[e("a",b,[o("module.loaded"),a(n)])]),e("li",null,[e("a",_,[o("module.parent"),a(n)])]),e("li",null,[e("a",g,[o("module.children"),a(n)])]),e("li",null,[e("a",x,[o("module.exports"),a(n)]),e("ul",null,[e("li",null,[e("a",f,[o("exports 的别名"),a(n)])])])]),e("li",null,[e("a",v,[o("module.require(id)"),a(n)])])])]),j])}const E=r(c,[["render",S],["__file","横向对比 CJS 和 ES Module.html.vue"]]);export{E as default};
