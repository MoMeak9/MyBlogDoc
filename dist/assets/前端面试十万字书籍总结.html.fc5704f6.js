import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as p,a as e,t as o,e as n}from"./app.d7b34baa.js";const i={},c=n(`<h1 id="前端面试十万字书籍总结" tabindex="-1"><a class="header-anchor" href="#前端面试十万字书籍总结" aria-hidden="true">#</a> 前端面试十万字书籍总结</h1><h2 id="javascript专题" tabindex="-1"><a class="header-anchor" href="#javascript专题" aria-hidden="true">#</a> JavaScript专题</h2><h3 id="防抖" tabindex="-1"><a class="header-anchor" href="#防抖" aria-hidden="true">#</a> 防抖</h3><p>你是否在⽇常开发中遇到⼀个问题，在滚动事件中需要做个复杂计算或者实现⼀个按钮的防⼆次点击操作。</p><p>这些需求都可以通过函数防抖动来实现。尤其是第⼀个需求，如果在频繁的事件回调中做复杂计算，很有可能导致⻚⾯卡顿，不如将多次计算合并为⼀次计算，只在⼀个精确点做操作。</p><p>PS：防抖和节流的作⽤都是防⽌函数多次调⽤。区别在于，假设⼀个⽤户⼀直触发这个函数，且每次触发函数的间隔⼩于wait，防抖的情况下只会调⽤⼀次，⽽节流的 情况会每隔⼀定时间（参数wait）调⽤函数。</p><p>我们先来看⼀个袖珍版的防抖理解⼀下防抖的实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// func是⽤户传⼊需要防抖的函数</span>
<span class="token comment">// wait是等待时间</span>
<span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 缓存⼀个定时器id</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">// 这⾥返回的函数是每次⽤户实际调⽤的防抖函数</span>
    <span class="token comment">// 如果已经设定过定时器了就清空上⼀次的定时器</span>
    <span class="token comment">// 开始⼀个新的定时器，延迟执⾏⽤户传⼊的⽅法</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 不难看出如果⽤户调⽤该函数的间隔⼩于wait的情况下，上⼀次的时间还未到就被清除了，并不会执⾏函数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是⼀个简单版的防抖，但是有缺陷，这个防抖只能在最后调⽤。⼀般的防抖会有immediate选项，表示是否⽴即调⽤。这两者的区别，举个栗⼦来说：</p><ul><li><p>例如在搜索引擎搜索问题的时候，我们当然是希望⽤户输⼊完最后⼀个字才调⽤查询接⼝，这个时候适⽤ 延迟执⾏ 的防抖函数，它总是在⼀连串（间隔⼩于wait的）函数触发之后调⽤。</p></li><li><p>例如⽤户给interviewMap点star的时候，我们希望⽤户点第⼀下的时候就去调⽤接⼝，并且成功之后改变star按钮的样⼦，⽤户就可以⽴⻢得到反馈是否star成功了，这个情况适⽤ ⽴即执⾏ 的防抖函数，它总是在第⼀次调⽤，并且下⼀次调⽤必须与前⼀次调⽤的时间间隔⼤于wait才会触发。</p></li></ul><p>下⾯我们来实现⼀个带有⽴即执⾏选项的防抖函数</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 这个是⽤来获取当前时间戳的</span>
<span class="token keyword">function</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 防抖函数，返回函数连续调⽤时，空闲时间必须⼤于或等于 wait，func 才会执⾏
 *
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span><span class="token keyword">function</span><span class="token punctuation">}</span></span> <span class="token parameter">func</span> 回调函数
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">wait</span> 表示时间窗⼝的间隔
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span> <span class="token parameter">immediate</span> 设置为ture时，是否⽴即调⽤函数
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span><span class="token keyword">function</span><span class="token punctuation">}</span></span> 返回客户调⽤函数
 */</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">,</span> immediate <span class="token operator">=</span> <span class="token boolean">true</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer<span class="token punctuation">,</span> context<span class="token punctuation">,</span> args

    <span class="token comment">// 延迟执⾏函数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">later</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 延迟函数执⾏完毕，清空缓存的定时器序号</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token comment">// 延迟执⾏的情况下，函数会在延迟函数中执⾏</span>
        <span class="token comment">// 使⽤到之前缓存的参数和上下⽂</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
            context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token comment">// 这⾥返回的函数是每次实际调⽤的函数</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果没有创建延迟执⾏函数（later），就创建⼀个</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            timer <span class="token operator">=</span> <span class="token function">later</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// 如果是⽴即执⾏，调⽤函数</span>
            <span class="token comment">// 否则缓存参数和调⽤上下⽂</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                context <span class="token operator">=</span> <span class="token keyword">this</span>
                args <span class="token operator">=</span> params
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果已有延迟执⾏函数（later），调⽤的时候清除原来的并重新设定⼀</span>
            <span class="token comment">// 这样做延迟函数会重新计时</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
            timer <span class="token operator">=</span> <span class="token function">later</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体函数实现的不难，总结⼀下。</p><ul><li><p>对于按钮防点击来说的实现：如果函数是⽴即执⾏的，就⽴即调⽤，如果函数是延迟执⾏的，就缓存上下⽂和参数，放到延迟函数中去执⾏。⼀旦我开始⼀个定时器，只要我定时器还在，你每次点击我都重新计时。⼀旦你点累了，定时器时间到，定时器重置为null ，就可以再次点击了。</p></li><li><p>对于延时执⾏函数来说的实现：清除定时器ID，如果是延迟调⽤就调⽤函数</p></li></ul><h3 id="节流" tabindex="-1"><a class="header-anchor" href="#节流" aria-hidden="true">#</a> 节流</h3><p>防抖动和节流本质是不⼀样的。防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏ 变成每隔⼀段时间执⾏。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">/*
   * 节流 思路：
   * 先开启一个定时任务执行，定时任务完成后则清空，当再调用时，如果定时任务仍存在则不执行任何操作
   * */</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> space</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            task <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> space<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> throttleShowLog <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="模拟实现-call-和-apply" tabindex="-1"><a class="header-anchor" href="#模拟实现-call-和-apply" aria-hidden="true">#</a> 模拟实现 call 和 apply</h3><p>可以从以下⼏点来考虑如何实现</p><ul><li><p>不传⼊第⼀个参数，那么默认为 window</p></li><li><p>改变了 this 指向，让新的对象可以执⾏该函数。那么思路是否可以变成给新的对象添加 ⼀个函数，然后在执⾏完以后删除？</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context <span class="token operator">=</span> context <span class="token operator">||</span> window
    <span class="token comment">// 给 context 添加⼀个属性</span>
    <span class="token comment">// getValue.call(a, &#39;yck&#39;, &#39;24&#39;) =&gt; a.fn = getValue</span>
    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// 核心</span>
    
    <span class="token comment">// 将 context 后⾯的参数取出来</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// getValue.call(a, &#39;yck&#39;, &#39;24&#39;) =&gt; a.fn(&#39;yck&#39;, &#39;24&#39;)</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token comment">// 删除 fn</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 call 的思路， apply 的实现也类似</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context <span class="token operator">=</span> context <span class="token operator">||</span> window
    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">let</span> result
    <span class="token comment">// 需要判断是否存储第⼆个参数</span>
    <span class="token comment">// 如果存在，就将第⼆个参数展开</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过bind 实现柯⾥化。</p><p>同样的，也来模拟实现下 bind</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&#39;Error&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// 返回⼀个函数</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 因为返回了⼀个函数，我们可以 new F()，所以需要判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">_this</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">_this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="promise-实现" tabindex="-1"><a class="header-anchor" href="#promise-实现" aria-hidden="true">#</a> Promise 实现</h3><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题。</p><p>可以把 Promise 看成⼀个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态⼀旦改变就不能再次变化。</p><h3 id="generator-实现" tabindex="-1"><a class="header-anchor" href="#generator-实现" aria-hidden="true">#</a> Generator 实现</h3><p>Generator 是 ES6 中新增的语法，和 Promise ⼀样，都可以⽤来异步编程</p><p>从以上代码可以发现，加上 * 的函数执⾏后拥有了 next 函数，也就是说函数执⾏后返回 了⼀个对象。每次调⽤ next 函数可以继续执⾏被暂停的代码。以下是 Generator 函数的简单实现。</p><h3 id="map、flatmap-和-reduce" tabindex="-1"><a class="header-anchor" href="#map、flatmap-和-reduce" aria-hidden="true">#</a> Map、FlatMap 和 Reduce</h3><p>Map 作⽤是⽣成⼀个新数组，遍历原数组，将每个元素拿出来做⼀些变换然后 append 到新 的数组中。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; [2, 3, 4]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Map 有三个参数，分别是当前索引元素，索引，原数组</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;2&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;3&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
<span class="token comment">// parseInt(&#39;1&#39;, 0) -&gt; 1</span>
<span class="token comment">// parseInt(&#39;2&#39;, 1) -&gt; NaN</span>
<span class="token comment">// parseInt(&#39;3&#39;, 2) -&gt; NaN</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FlatMap 和 map 的作⽤⼏乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 FlatMap 看成是 map + flatten ，⽬前该函数在浏览器中还不⽀持。</p><p>而且仅支持一维</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; [ 2, &#39;21&#39;, 4 ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想将⼀个<strong>多维数组彻底的降维</strong>，可以这样实现</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">flattenDeep</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
 <span class="token operator">?</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token function">flattenDeep</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token operator">:</span> <span class="token punctuation">[</span>arr<span class="token punctuation">]</span>
<span class="token function">flattenDeep</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Reduce 作⽤是数组中的值组合起来，最终得到⼀个值</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; 2 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>async 和 await ⼀个函数如果加上 async ，那么该函数就会返回⼀个 Promise</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; Promise {&lt;resolved&gt;: &quot;1&quot;}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以把 async 看成将函数返回值使⽤ Promise.resolve() 包裹了下。</p><p>await 只能在 async 函数中使⽤。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;finish&#39;</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;sleep&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上⾯代码会先打印 finish 然后再打印 object 。因为 await 会等待 sleep 函数resolve ，所以即使后⾯是同步代码，也不会先去执⾏同步代码再来执⾏异步代码。</p><p>async 和 await 相⽐直接使⽤ Promise 来说，优势在于处理 then 的调⽤链，能够更清晰准确的写出代码。缺点在于滥⽤ await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><p>下⾯来看⼀个使⽤ await 的代码。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">var</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token keyword">await</span> <span class="token number">10</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;2&#39;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">// -&gt; &#39;2&#39; 10</span>
    a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> a
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;3&#39;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">// -&gt; &#39;3&#39; 20</span>
<span class="token punctuation">}</span>
<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
a<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">// -&gt; &#39;1&#39; 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于以上代码你可能会有疑惑，这⾥说明下原理</p><ul><li>⾸先函数 b 先执⾏，在执⾏到 await 10 之前变量 a 还是 0，因为在 await 内部实现了 generators ， generators 会保留堆栈中东⻄，所以这时候 a = 0 被保存了下来</li><li>因为 await 是异步操作，遇到 await 就会⽴即返回⼀个 pending 状态的 Promise 对象，暂时返回执⾏代码的控制权，使得函数外的代码得以继续执⾏，所以会先执⾏console.log(&#39;1&#39;, a)</li><li>这时候同步代码执⾏完毕，开始执⾏异步代码，将保存下来的值拿出来使⽤，这时候 a = 10</li><li>然后后⾯就是常规执⾏代码了</li></ul><h3 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> Proxy</h3><p>Proxy 是 ES6 中新增的功能，可以⽤来⾃定义对象中的操作</p><h3 id="图层" tabindex="-1"><a class="header-anchor" href="#图层" aria-hidden="true">#</a> 图层</h3><p>⼀般来说，可以把普通⽂档流看成⼀个图层。特定的属性可以⽣成⼀个新的图层。不同的图 层渲染互不影响，所以对于某些频繁需要渲染的建议单独⽣成⼀个新图层，提⾼性能。但也 不能⽣成过多的图层，会引起反作⽤。</p><p>通过以下⼏个常⽤属性可以⽣成新图层</p><ul><li>3D 变换： translate3d 、 translateZ</li><li>will-change</li><li>video 、 iframe 标签</li><li>通过动画实现的 opacity 动画转换</li><li>position: fixed</li></ul><p>重绘（Repaint）和回流（Reflow） 重绘和回流是渲染步骤中的⼀⼩节，但是这两个步骤对于性能影响很⼤。</p><ul><li>重绘是当节点需要更改外观⽽不会影响布局的，⽐如改变 color 就叫称为重绘</li><li>回流是布局或者⼏何属性需要改变就称为回流</li></ul><p>回流必定会发⽣重绘，重绘不⼀定会引发回流。回流所需的成本⽐重绘⾼的多，改变深层次 的节点很可能导致⽗节点的⼀系列回流。</p><p>所以以下⼏个动作可能会导致性能问题：</p><ul><li>改变 window ⼤⼩</li><li>改变字体</li><li>添加或删除样式</li><li>⽂字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p>很多⼈不知道的是，重绘和回流其实和 Event loop 有关。</p><ol><li>当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是60Hz 的刷新率，每 16ms 才会更新⼀次。</li><li>...</li><li>执⾏ requestAnimationFrame 回调</li></ol><h3 id="减少重绘和回流" tabindex="-1"><a class="header-anchor" href="#减少重绘和回流" aria-hidden="true">#</a> 减少重绘和回流</h3><ul><li><p>使⽤ translate 替代 top</p></li><li><p>使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流 （改变了布局）</p></li><li><p>把 DOM 离线后修改，⽐如：先把 DOM 给 display:none (有⼀次 Reflow)，然后你修 改100次，然后再把它显示出来</p></li><li><p>不要把 DOM 结点的属性值放在⼀个循环⾥当成循环⾥的变量</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;.test&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局</p></li><li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤ requestAnimationFrame</p></li><li><p>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</p></li><li><p>将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video 标签，浏览器会⾃动将该节点变为图层。</p></li></ul><h2 id="性能章节" tabindex="-1"><a class="header-anchor" href="#性能章节" aria-hidden="true">#</a> 性能章节</h2><h3 id="dns-预解析" tabindex="-1"><a class="header-anchor" href="#dns-预解析" aria-hidden="true">#</a> DNS 预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的⽅式来预先获得域名所对应的 IP</p><h3 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h3><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提⾼ ⽹⻚的整体加载速度。</p><p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p><p><strong>强缓存</strong></p><p>实现强缓存可以通过两种响应头实现： Expires 和 Cache-Control 。强缓存表示在缓存期 间不需要请求， state code 为 200</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过 期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存 失效。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Cache-control: max-age=30
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Cache-Control 出现于 HTTP / 1.1，优先级⾼于 Expires 。该属性表示资源会在 30 秒后 过期，需要再次请求。</p><p><strong>协商缓存</strong></p><p>如果缓存过期了，我们就可以使⽤协商缓存来解决问题。协商缓存需要请求，如果缓存有效 会返回 304。</p><p>协商缓存需要客户端和服务端共同实现，和强缓存⼀样，也有两种实现⽅式。</p><p><strong>Last-Modified 和 If-Modified-Since</strong></p><p>Last-Modified 表示本地⽂件最后修改⽇期， If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该⽇期后资源是否有更新，有更新的话就会将新的资源发 送回来。</p><p>但是如果在<strong>本地打开缓存⽂件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现 了 ETag 。</strong></p><p><strong>ETag 和 If-None-Match</strong></p><p>ETag 类似于⽂件指纹， If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级⽐ Last-Modified ⾼。</p><h3 id="选择合适的缓存策略" tabindex="-1"><a class="header-anchor" href="#选择合适的缓存策略" aria-hidden="true">#</a> 选择合适的缓存策略</h3><p>对于⼤部分的场景都可以使⽤强缓存配合协商缓存解决，但是在⼀些特殊的地⽅可能需要选 择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使⽤ <strong>Cache-control: no-store</strong> ，表示该资源不需 要缓存</li><li>对于频繁变动的资源，可以使⽤ <strong>Cache-Control: no-cache 并配合 ETag 使⽤</strong>，表示 该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码⽂件来说，通常使⽤ Cache-Control: max-age=31536000(超长时间) 并配合策略缓存使⽤，<strong>然后对⽂件进⾏指纹处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件</strong>。</li></ul><h3 id="使用-http-2-0" tabindex="-1"><a class="header-anchor" href="#使用-http-2-0" aria-hidden="true">#</a> 使⽤ HTTP / 2.0</h3><p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建⽴和断开，消耗了好⼏个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积⼤的⽂件会需要更多的时间。</p><p>在 HTTP / 2.0 中引⼊了多路复⽤，能够让多个请求使⽤同⼀个 TCP 链接，极⼤的加快了⽹ ⻚的加载速度。并且还⽀持 Header 压缩，进⼀步的减少了请求的数据⼤⼩。</p><h3 id="预加载" tabindex="-1"><a class="header-anchor" href="#预加载" aria-hidden="true">#</a> 预加载</h3><p>在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候 就可以使⽤预加载。</p><p>预加载其实是<strong>声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件</strong>，可以 使⽤以下代码开启预加载</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot;&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后 加载，唯⼀缺点就是兼容性不好。</p><h3 id="预渲染" tabindex="-1"><a class="header-anchor" href="#预渲染" aria-hidden="true">#</a> 预渲染</h3><p>可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com&quot;&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则 就⽩⽩浪费资源去渲染</p><h3 id="优化渲染过程" tabindex="-1"><a class="header-anchor" href="#优化渲染过程" aria-hidden="true">#</a> 优化渲染过程</h3><p><strong>懒执⾏</strong></p><p>懒执⾏就是将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑 并<strong>不需要在⾸屏就使⽤的</strong>，就可以使⽤懒执⾏。<strong>懒执⾏需要唤醒，⼀般可以通过定时器或者 事件的调⽤来唤醒。</strong></p><p><strong>懒加载</strong></p><p>懒加载就是将不关键的资源延后加载。</p><p>懒加载的原理就是只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域）内 需要加载的东⻄。<strong>对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，将真实的图⽚ 资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样 图⽚就会去下载资源，实现了图⽚懒加载</strong>。</p><p>懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等 等。</p><h2 id="文件优化" tabindex="-1"><a class="header-anchor" href="#文件优化" aria-hidden="true">#</a> ⽂件优化</h2><h3 id="图片优化" tabindex="-1"><a class="header-anchor" href="#图片优化" aria-hidden="true">#</a> 图⽚优化</h3><p><strong>图⽚加载优化</strong></p><ol><li>不⽤图⽚。很多时候会使⽤到很多修饰类图⽚，其实这类修饰图⽚完全可以⽤ CSS 去代 替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。⼀般图⽚都⽤ CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图⽚。</li><li>⼩图使⽤ base64 格式</li><li>将多个图标⽂件整合到⼀张图⽚中（雪碧图）</li><li>选择正确的图⽚格式：</li></ol><ul><li>对于能够显示 WebP 格式的浏览器尽量使⽤ WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更⼩的图⽚体积，⽽且拥有⾁眼识别⽆差异的图像质量，缺点就是兼容性并不好</li><li>⼩图使⽤ PNG，其实对于⼤部分图标这类图⽚，完全可以使⽤ SVG 代替</li><li>照⽚使⽤ JPEG</li></ul><p><strong>其他⽂件优化</strong></p><ul><li>CSS ⽂件放在 head 中</li><li>服务端开启⽂件压缩功能</li><li>将 script 标签放在 body 底部，因为 JS ⽂件执⾏会阻塞渲染。当然也可以把script 标签放在任意位置然后加上 <strong>defer</strong> ，表示该⽂件会<strong>并⾏下载</strong>，但是会放到HTML 解析完成后顺序执⾏。对于没有任何依赖的 JS ⽂件可以加上 <strong>async</strong> ，表示<strong>加载和渲染后续⽂档元素的过程将和 JS ⽂件的加载与执⾏并⾏⽆序进⾏</strong>。</li><li>执⾏ JS 代码过⻓会卡住渲染，对于需要很多时间计算的代码可以考虑使⽤ Webworker 。 Webworker 可以让我们另开⼀个线程执⾏脚本⽽不影响渲染。</li></ul><p><strong>CDN</strong></p><p>静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带 上主站的 Cookie。</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><p><strong>使⽤ Webpack 优化项⽬</strong></p><ul><li>对于 Webpack4，打包项⽬使⽤ production 模式，这样会⾃动开启代码压缩</li><li>使⽤ ES6 模块来开启 tree shaking(树摇)，这个技术可以移除没有使⽤的代码</li><li>优化图⽚，对于⼩图可以使⽤ base64 的⽅式写⼊⽂件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的⽂件名添加哈希，实现浏览器缓存⽂</li></ul><p><strong>如何渲染⼏万条数据并不卡住界⾯</strong></p><p>这道题考察了如何在不卡住⻚⾯的情况下渲染数据，也就是说不能⼀次性将⼏万条都渲染出来，⽽应该⼀次渲染部分 DOM，<strong>那么就可以通过 requestAnimationFrame 来每 16 ms刷 新⼀次</strong>。</p><h2 id="框架基本原理篇" tabindex="-1"><a class="header-anchor" href="#框架基本原理篇" aria-hidden="true">#</a> 框架基本原理篇</h2><p>MVVM 由以下三个内容组成</p><p>View：界⾯</p><p>Model：数据模型</p><p>ViewModel：作为桥梁负责沟通 View 和 Model</p><p>在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务 的逻辑就和⻚⾯有强耦合。</p><p>在 MVVM 中，UI 是通过数据驱动的，数据⼀旦改变就会相应的刷新对应的 UI，UI 如果改 变，也会改变对应的数据。这种⽅式就可以在业务处理中只关⼼数据的流转，⽽⽆需直接和 ⻚⾯打交道。ViewModel 只关⼼数据和业务的处理，不关⼼ View 如何处理数据，在这种情况 下，View 和 Model 都可以独⽴出来，任何⼀⽅改变了也不⼀定需要改变另⼀⽅，并且可以将 ⼀些可复⽤的逻辑放在⼀个 ViewModel 中，让多个 View 复⽤这个 ViewModel。</p><p>在 MVVM 中，最核⼼的也就是<strong>数据双向绑定</strong>，例如 Angluar 的脏数据检测，<strong>Vue 中的数据劫持。</strong></p><h3 id="数据劫持" tabindex="-1"><a class="header-anchor" href="#数据劫持" aria-hidden="true">#</a> 数据劫持</h3><p>Vue2 内部使⽤了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。</p><p>以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需 要在适当的时候给属性添加发布订阅</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
 {{name}}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,138),l=n(`<h3 id="proxy-与-object-defineproperty-对比" tabindex="-1"><a class="header-anchor" href="#proxy-与-object-defineproperty-对比" aria-hidden="true">#</a> Proxy 与 Object.defineProperty 对⽐</h3><p>Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p><ol><li>只能对属性进⾏数据劫持，所以需要<strong>深度遍历整个对象</strong></li><li>对于数组不能监听到数据的变化(Vue2重写数组方法)</li></ol><h3 id="路由原理" tabindex="-1"><a class="header-anchor" href="#路由原理" aria-hidden="true">#</a> 路由原理</h3><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的 ⻚⾯，并且⽆须刷新。⽬前单⻚⾯使⽤的路由就只有两种实现⽅式</p><ul><li>hash 模式</li><li>history 模式</li></ul><p>www.test.com/#/ 就是 Hash URL，当 # 后⾯的哈希值发⽣变化时，不会向服务器请求数 据，可以通过 <strong>hashchange 事件</strong>来监听到 URL 的变化，从⽽进⾏跳转⻚⾯。</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220330135438925.png" alt="image-20220330135438925"></p><p><strong>History</strong> 模式是 <strong>HTML5 新推出的功能</strong>，⽐之 Hash URL 更加美观</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220330135446497.png" alt="image-20220330135446497"></p><h3 id="virtual-dom" tabindex="-1"><a class="header-anchor" href="#virtual-dom" aria-hidden="true">#</a> Virtual Dom</h3><p><strong>为什么需要 Virtual Dom</strong></p><p>众所周知，操作 DOM 是很耗费性能的⼀件事情，既然如此，我们可以考虑通过 JS 对象来模 拟 DOM 对象，毕竟操作 JS 对象⽐操作 DOM 省时的多。</p><p>当然在实际操作中，我们还需要给每个节点⼀个标识，作为判断是同⼀个节点的依据。<strong>所以 这也是 Vue 和 React 中官⽅推荐列表⾥的节点使⽤唯⼀的 key 来保证性能</strong>。</p><p>那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM</p><p><strong>Virtual Dom 算法简述</strong> DOM 是多叉树的结构，<strong>如果需要完整的对⽐两颗树的差异</strong>，那么需要的时间复杂度会是 O(n^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对⽐差异。</p><p>实现 O(n) 复杂度的关键就是**<u>只对⽐同层的节点，⽽不是跨层对⽐</u><strong>，这也是考虑到在实际业</strong>务中很少会去跨层的移动 DOM 元素。**</p><p>所以判断差异的算法就分为了<strong>两步</strong></p><ul><li>⾸先从上⾄下，从左往右遍历对象，也就是树的<strong>深度遍历</strong>，<strong>这⼀步中会给每个节点添加索引，便于最后渲染差异</strong></li><li>⼀旦节点有⼦元素，就去判断⼦元素是否有不同</li></ul><h2 id="vue-章节" tabindex="-1"><a class="header-anchor" href="#vue-章节" aria-hidden="true">#</a> Vue 章节</h2><h3 id="nexttick-原理分析" tabindex="-1"><a class="header-anchor" href="#nexttick-原理分析" aria-hidden="true">#</a> NextTick 原理分析</h3><p>nextTick 可以让我们在<strong>下次 DOM 更新循环结束之后</strong>执⾏延迟回调，⽤于获得更新后的 DOM。</p><h3 id="生命周期分析" tabindex="-1"><a class="header-anchor" href="#生命周期分析" aria-hidden="true">#</a> ⽣命周期分析</h3><p>⽣命周期函数就是组件在初始化或者数据更新时会触发的钩⼦函数。</p><ul><li>created</li><li>mounted</li><li>upadted</li><li>destoryed</li></ul><h2 id="安全章节" tabindex="-1"><a class="header-anchor" href="#安全章节" aria-hidden="true">#</a> 安全章节</h2><h3 id="xss" tabindex="-1"><a class="header-anchor" href="#xss" aria-hidden="true">#</a> XSS</h3><blockquote><p>跨⽹站指令码（英语：Cross-site scripting，通常简称为：XSS）是⼀种⽹站应⽤程 式的安全漏洞攻击，是代码注⼊的⼀种。它允许恶意使⽤者将程式码注⼊到⽹⻚上， 其他使⽤者在观看⽹⻚时就会受到影响。这类攻击通常包含了 HTML 以及使⽤者端 脚本语⾔。</p></blockquote><p>XSS 分为三种：反射型，存储型和 DOM-based</p><ul><li>例如通过 URL 获取某些参数</li><li>⽐如写了⼀篇包含攻击代码 的⽂章</li></ul><p><strong>如何防御</strong></p><p>最普遍的做法是转义输⼊输出的内容，对于<strong>引号，尖括号，斜杠</strong>进⾏转义</p><p>对于显示富⽂本来说，<strong>不能通过上⾯的办法来转义所有字符，因为这样会把需要的格式也过滤掉</strong>。这种情况通常采⽤<strong>⽩名单过滤</strong>的办法，当然也可以通过⿊名单过滤，但是考虑到需要 过滤的标签和标签属性实在太多，更加推荐使⽤⽩名单的⽅式。</p><h3 id="csp" tabindex="-1"><a class="header-anchor" href="#csp" aria-hidden="true">#</a> CSP</h3><blockquote><p>内容安全策略 (CSP) 是⼀个额外的安全层，⽤于检测并削弱某些特定类型的攻击， 包括跨站脚本 (XSS) 和数据注⼊攻击等。⽆论是数据盗取、⽹站内容污染还是散发恶 意软件，这些攻击都是主要的⼿段。</p></blockquote><h3 id="csrf" tabindex="-1"><a class="header-anchor" href="#csrf" aria-hidden="true">#</a> CSRF</h3><blockquote><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或 者 session riding，通常缩写为 CSRF 或者 XSRF， 是⼀种挟制⽤户在当前已登录 的Web应⽤程序上执⾏⾮本意的操作的攻击⽅法。跟跨網站指令碼（XSS）相 ⽐，XSS 利⽤的是⽤户对指定⽹站的信任，CSRF 利⽤的是⽹站对⽤户⽹⻚浏览器 的信任。</p></blockquote><p>假设⽹站中有⼀个通过 Get 请求提交⽤户评论的接⼝，那么攻击者就可以在钓⻥⽹站中加⼊ ⼀个图⽚，图⽚的地址就是评论接⼝</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">&quot;http://www.domain.com/xxx?comment=&#39;attack&#39;&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果接⼝是 Post 提交的，就相对麻烦点，需要⽤表单来提交接⼝</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.domain.com/xxx<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>CSRF<span class="token punctuation">&quot;</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>post<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>comment<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>attack<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hidden<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如何防御</strong></p><p>防范 CSRF 可以遵循以下⼏种规则：</p><ol><li>Get 请求不对数据进⾏修改</li><li>不让第三⽅⽹站访问到⽤户 Cookie</li><li>阻⽌第三⽅⽹站请求接⼝</li><li>请求时附带验证信息，⽐如验证码或者 token</li></ol><p><strong>SameSite</strong></p><p>可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很⼤程度减少 CSRF 的攻击，但是该属性⽬前并不是所有浏览器都兼容。</p><p><strong>验证 Referer</strong></p><p>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三⽅⽹站发起的。（用referer来判断上一页面是不是自己网站）</p><p><strong>Token</strong></p><p>服务器下发⼀个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p><h2 id="密码安全" tabindex="-1"><a class="header-anchor" href="#密码安全" aria-hidden="true">#</a> 密码安全</h2><p>密码安全虽然⼤多是后端的事情，但是作为⼀名优秀的前端程序员也需要熟悉这⽅⾯的知识。</p><p><strong>加盐</strong></p><p>对于密码存储来说，必然是不能明⽂存储在数据库中的，否则⼀旦数据库泄露，会对⽤户造 成很⼤的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。</p><h2 id="网络章节" tabindex="-1"><a class="header-anchor" href="#网络章节" aria-hidden="true">#</a> ⽹络章节</h2><h3 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h3><p><strong>⾯向报⽂</strong></p><p>UDP 是⼀个⾯向报⽂（报⽂可以理解为⼀段段的数据）的协议。意思就是 UDP 只是报⽂的搬运⼯，不会对报⽂进⾏任何拆分和拼接操作。</p><p>具体来说</p><ul><li>在发送端，应⽤层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加⼀个 UDP 头标识下是 UDP 协议，然后就传递给⽹络层了</li><li>在接收端，⽹络层将数据传递给传输层，UDP 只去除 IP 报⽂头就传递给应⽤层，不会任何拼接操作</li></ul><p><strong>不可靠性</strong></p><ol><li>UDP 是⽆连接的，也就是说通信不需要建⽴和断开连接。</li><li>UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对⽅能不能收到是不关⼼的</li><li>UDP 没有拥塞控制，⼀直会以恒定的速度发送数据。即使⽹络条件不好，也不会对发送速率进⾏调整。这样实现的弊端就是在⽹络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求⾼的场景（⽐如电话会议）就需要使⽤ UDP ⽽不是 TCP。</li></ol><p><strong>⾼效</strong></p><p>因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。<strong>所以 UDP 的头部开销⼩， 只有⼋字节，相⽐ TCP 的⾄少⼆⼗字节要少得多</strong>，在传输数据报⽂时是很⾼效的。</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220331003314946.png" alt="image-20220331003314946"></p><p>头部包含了以下⼏个数据</p><ul><li>两个⼗六位的端⼝号，分别为源端⼝（可选字段）和⽬标端⼝</li><li>整个数据报⽂的⻓度</li><li>整个数据报⽂的检验和（IPv4 可选 字段），该字段⽤于发现头部信息和数据中的错误</li></ul><p><strong>传输⽅式</strong></p><p>UDP 不⽌⽀持⼀对⼀的传输⽅式，同样⽀持⼀对多，多对多，多对⼀的⽅式，也就是说 UDP</p><p>提供了单播，多播，⼴播的功能</p><h3 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h3><p><strong>头部</strong></p><p>TCP 头部⽐ UDP 头部复杂的多</p><p><img src="https://my-doc-1259409954.file.myqcloud.com/MyImages/image-20220402002917867.png" alt="image-20220402002917867"></p><p>对于 TCP 头部来说，以下⼏个字段是很重要的</p><ul><li>Sequence number，这个序号保证了 TCP 传输的报⽂都是有序的，对端可以通过序号顺 序的拼接报⽂</li><li>Acknowledgement Number，这个序号表示数据接收端期望接收的下⼀个字节的编号是 多少，同时也表示上⼀个序号的数据已经收到</li><li>Window Size，窗⼝⼤⼩，表示还能接收多少字节的数据，⽤于流量控制</li><li>标识符</li></ul><h3 id="建立连接三次握手" tabindex="-1"><a class="header-anchor" href="#建立连接三次握手" aria-hidden="true">#</a> 建⽴连接三次握⼿</h3><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/2019082918370937.png" alt="img"></p><p><strong>你是否有疑惑明明两次握⼿就可以建⽴起连接，为什么还需要第三次应答？</strong></p><p>因为这是为了防⽌失效的连接请求报⽂段被服务端接收（避免丢包的情况），从⽽产⽣错误。</p><p>可以想象如下场景。客户端发送了⼀个连接请求 A，但是因为⽹络原因造成了超时，这时TCP 会启动超时重传的机制再次发送⼀个连接请求 B。此时请求顺利到达服务端，服务端应答完就建⽴了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端⼜需要建⽴ TCP 连接，从⽽应答了该请求并进⼊ ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端⼀直等待，造成资源的浪费。</p><p>PS：在建⽴连接中，任意⼀端掉线，TCP 都会重发 SYN 包，⼀般会重试五次，在建⽴连接 中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者⼲脆在不能处 理的情况下拒绝请求。</p><h3 id="断开链接四次握手" tabindex="-1"><a class="header-anchor" href="#断开链接四次握手" aria-hidden="true">#</a> 断开链接四次握⼿</h3><p><strong>为什么 A 要进⼊ TIME-WAIT 状态，等待 2MSL 时间后才进⼊ CLOSED 状态？</strong></p><p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进⼊ CLOSED 状态，如果确认 应答因为⽹络问题⼀直没有到达，那么会造成 B 不能正常关闭。</p><h3 id="arq-协议" tabindex="-1"><a class="header-anchor" href="#arq-协议" aria-hidden="true">#</a> ARQ 协议</h3><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含 停⽌等待 ARQ 和连续 ARQ。</p><h3 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗⼝</h3><p>在上⾯⼩节中讲到了发送窗⼝。在 TCP 中，两端都维护着窗⼝：分别为<strong>发送端窗⼝</strong>和<strong>接收端窗⼝</strong>。</p><p>发送端窗⼝包含已<strong>发送但未收到应答的数据和可以发送但是未发送的数据</strong></p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220403162841916.png" alt="image-20220403162841916"></p><p>发送端窗⼝是由接收窗⼝剩余⼤⼩决定的。接收⽅会把当前接收窗⼝的剩余⼤⼩写⼊应答报 ⽂，<strong>发送端收到应答后根据该值和当前⽹络拥塞情况设置发送窗⼝的⼤⼩</strong>，所以发送窗⼝的 ⼤⼩是不断变化的。</p><p>当发送端接收到应答报⽂后，会随之将窗⼝进⾏滑动</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220403162859663.png" alt="image-20220403162859663"></p><p>滑动窗⼝实现了流量控制。接收⽅通过报⽂告知发送⽅还可以发送多少数据，从⽽保证接收 ⽅能够来得及接收数据。</p><p><strong>Zero 窗⼝</strong></p><p>在发送报⽂的过程中，可能会遇到对端出现零窗⼝的情况。在该情况下，发送端会停⽌发送 数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗⼝⼤⼩。在 重试次数超过⼀定次数后，可能会中断 TCP 链接。</p><h3 id="拥塞处理" tabindex="-1"><a class="header-anchor" href="#拥塞处理" aria-hidden="true">#</a> 拥塞处理</h3><p>拥塞处理和流量控制不同，后者是作⽤于接收⽅，保证接收⽅来得及接受数据。⽽前者是作 ⽤于⽹络，防⽌过多的数据拥塞⽹络，避免出现⽹络负载过⼤的情况。</p><p>拥塞处理包括了四个算法，分别为：<strong>慢开始，拥塞避免，快速重传，快速恢复</strong>。</p><p><strong>慢开始算法</strong></p><p>慢开始算法，顾名思义，就是在传输开始时将发送窗⼝慢慢指数级扩⼤，从⽽避免⼀开始就 传输⼤量数据导致⽹络拥塞。</p><p>慢开始算法步骤具体如下</p><ol><li>连接初始设置<strong>拥塞窗⼝（Congestion Window）</strong> 为 1 MSS（⼀个分段的最⼤数据量）</li><li>每过⼀个 RTT 就将窗⼝⼤⼩乘⼆</li><li>指数级增⻓肯定不能没有限制的，所以有⼀个阈值限制，当窗⼝⼤⼩⼤于阈值时就会启动 拥塞避免算法。</li></ol><p><strong>拥塞避免算法</strong></p><p>拥塞避免算法相⽐简单点，每过⼀个 RTT (来回通讯延迟 Round-trip delay)窗⼝⼤⼩只加⼀，这样能够避免指数级增⻓导致⽹ 络拥塞，慢慢将⼤⼩调整到最佳值。</p><p>在传输过程中可能<strong>定时器超时的情况，这时候 TCP 会认为⽹络拥塞了</strong>，会⻢上进⾏以下步骤：</p><ul><li>将阈值设为当前拥塞窗⼝的⼀半</li><li>将拥塞窗⼝设为 1 MSS</li><li>启动拥塞避免算法</li></ul><p><strong>快速重传</strong></p><p><strong>快速重传⼀般和快恢复⼀起出现</strong>。⼀旦接收端收到的报⽂出现失序的情况，接收端只会回复 最后⼀个顺序正确的报⽂序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，⽆需等 待定时器超时再重发⽽是启动快速重传。具体算法分为两种：</p><h3 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h3><p>HTTP 协议是个⽆状态协议，不会保存状态。</p><p><strong>Post 和 Get 的区别</strong></p><p>先引⼊<strong>副作⽤</strong>和幂等的概念。</p><p><strong>副作⽤指对服务器上的资源做改变</strong>，搜索是⽆副作⽤的，注册是副作⽤的。</p><p>幂等指发送 M 和 N 次请求（两者不相同且都⼤于 1），服务器上资源的状态⼀致，⽐如注册 10 个和 11 个帐号是不幂等的，对⽂章进⾏更改 10 次和 11 次是幂等的。</p><p>在规范的应⽤场景上说，Get 多⽤于⽆副作⽤，幂等的场景，例如搜索关键字。Post 多⽤于 副作⽤，不幂等的场景，例如注册。</p><p>在技术上说：</p><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全⼀点点，因为Get 请求都包含在 URL ⾥，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是⼀样的。</li><li>Post 可以通过 request body来传输⽐ Get 更多的数据，Get 没有这个技术</li><li>URL有⻓度限制，会影响 Get 请求，但是这个⻓度限制是浏览器规定的，不是 RFC （Request for Comments，请求意见稿的相关标准）规定的</li><li>Post ⽀持更多的编码类型且不对数据类型限制</li></ul><h3 id="常⻅状态码" tabindex="-1"><a class="header-anchor" href="#常⻅状态码" aria-hidden="true">#</a> 常⻅状态码</h3><p><strong>2XX 成功</strong></p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报⽂不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报⽂不含实体的主体部分，但是与 204 响应 不同在于要求请求⽅重置内容</li><li>206 Partial Content，进⾏范围请求</li></ul><p><strong>3XX 重定向</strong></p><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求⽅法不 变向新的地址发出请求</li></ul><p><strong>4XX 客户端错误</strong></p><ul><li>400 bad request，请求报⽂存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><p><strong>5XX 服务器错误</strong></p><ul><li>500 internal sever error，表示服务器端在执⾏请求时发⽣了错误</li><li>501 Not Implemented，表示服务器不⽀持当前请求所需要的某个功能</li><li>502 Bad Gateway ，一般来自上游服务器无效响应，多来自nginx配置错误</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</li></ul><p><strong>HTTP ⾸部</strong></p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220403170029317.png" alt="image-20220403170029317"></p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220403170154916.png" alt="image-20220403170154916"></p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220403170338157.png" alt="image-20220403170338157"></p><h3 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h3><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进⾏了加密。</p><p><strong>TLS</strong>⭐</p><p>TLS 协议位于传输层之上，应⽤层之下。⾸次进⾏ TLS 协议传输需要两个 RTT ，接下来可以 通过 Session Resumption 减少到⼀个 RTT。</p><p>在 TLS 中使⽤了两种加密技术，分别为：对称加密和⾮对称加密。</p><p><strong>对称加密</strong></p><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密⽂加密解密。</p><p><strong>⾮对称加密：</strong></p><p>有公钥私钥之分，公钥所有⼈都可以知道，可以将数据⽤公钥加密，但是将数据解密必须使 ⽤私钥解密，私钥只有分发公钥的⼀⽅才知道。</p><p><strong>TLS 握⼿过程如下图：</strong></p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/20210130224551735.png" alt="HTTPS(二) -- SSL/TLS 工作原理和详细握手过程_-出发-的博客-CSDN博客_ssl具体握手过程" style="zoom:80%;"><ol><li>客户端发送⼀个随机值，需要的协议和加密⽅式</li><li>服务端收到客户端的随机值，⾃⼰也产⽣⼀个随机值，并根据客户端需求的协议和加密⽅式来使⽤对应的⽅式，发送⾃⼰的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再⽣成⼀个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使⽤私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密⽅式⽣成密钥，接下来的通信就可以通过该密钥来加密解密</li></ol><p>通过以上步骤可知，在 TLS 握⼿阶段，两端使⽤⾮对称加密的⽅式来通信，但是因为⾮对称 加密损耗的性能⽐对称加密⼤，<strong>所以在正式传输数据时，两端使⽤对称加密的⽅式通信。</strong></p><p>PS：以上说明的都是 TLS 1.2 协议的握⼿情况，在 1.3 协议中，⾸次建⽴连接只需要⼀个 RTT，后⾯恢复连接不需要 RTT 了。</p><h3 id="http-2-0" tabindex="-1"><a class="header-anchor" href="#http-2-0" aria-hidden="true">#</a> HTTP 2.0</h3><p>HTTP 2.0 相⽐于 HTTP 1.X，可以说是⼤幅度提⾼了 web 的性能。</p><p>在 HTTP 1.X 中，为了性能考虑，我们会引⼊雪碧图、将⼩图内联、使⽤多个域名等等的⽅式。这⼀切都是因为浏览器限制了同⼀个域名下的请求数量，当⻚⾯中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最⼤请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><p>在 HTTP 1.X 中，因为<strong>队头阻塞</strong>的原因，你会发现请求是这样的</p><p><strong>队头阻塞（head-of-line blocking）<strong>发生在一个</strong>TCP分节丢失，导致其后续分节不按序到达接收的时候。</strong> 该后续分节将被接收端一直保持，直到丢失的第一个分节被发送端重传并到达接收为止。 该后续分节的延迟递送<strong>确保接收应用进程能够按照发送端的发送顺序接收数据</strong>。</p><ol><li><p><strong>⼆进制传输</strong></p><p>HTTP 2.0 中所有加强性能的核⼼点在于此。在之前的 HTTP 版本中，我们是通过<strong>⽂本的⽅式 传数据</strong>。在 HTTP 2.0 中引⼊了新的编码机制，<strong>所有传输的数据都会被分割，并采⽤⼆进制 格式码</strong>。</p></li><li><p><strong>多路复⽤</strong></p><p>在 HTTP 2.0 中，有两个⾮常重要的概念，分别是<strong>帧（frame）和流（stream）</strong>。</p><p>帧代表着最⼩的数据单位，<strong>每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流</strong>。</p><p>多路复⽤，就是在⼀个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以<strong>避免 HTTP 旧版本中的队头阻塞问题，极⼤的提⾼传输性能。</strong></p></li><li><p><strong>Header 压缩</strong></p><p>在 HTTP 1.X 中，我们使⽤⽂本的形式传输 header，在 header 携带 cookie 的情况下，可能 每次都需要重复传输⼏百到⼏千的字节。</p><p>在 HTTP 2.0 中，使⽤了 <strong>HPACK 压缩格式对传输的 header 进⾏编码</strong>，减少了 header 的⼤ ⼩。<strong>并在两端维护了索引表，⽤于记录出现过的 header</strong> ，<strong>后⾯在传输过程中就可以传输已经 记录过的 header 的键名</strong>，对端收到数据后就可以通过键名找到对应的值。</p></li><li><p><strong>服务端 Push</strong></p><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p><p>可以想象以下情况，某些资源客户端是⼀定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少⼀点延迟时间。当然在浏览器兼容的情 况下你也可以使⽤ prefetch 。</p></li></ol><h3 id="quic" tabindex="-1"><a class="header-anchor" href="#quic" aria-hidden="true">#</a> QUIC</h3><p>这是⼀个⾕歌出品的基于 UDP 实现的同为传输层的协议，⽬标很远⼤，希望替代 TCP 协议。</p><ul><li>该协议⽀持多路复⽤，虽然 HTTP 2.0 也⽀持多路复⽤，但是下层仍是 TCP，因为 TCP的重传机制，只要⼀个包丢失就得判断丢失包并且重传，导致发⽣队头阻塞的问题，但是UDP 没有这个机制</li><li><strong>实现了⾃⼰的加密协议</strong>，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了</li><li>⽀持重传和纠错机制（向前恢复），在只丢失⼀个包的情况下不需要重传，使⽤纠错机制恢复丢失的包 <ul><li>**纠错机制：**通过异或的⽅式，算出发出去的数据的异或值并单独发出⼀个包，服务端在发现有⼀个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li><li>在丢失两个包或以上的情况就使⽤重传机制，因为算不出来了</li></ul></li></ul><h3 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h3><p>DNS 的作⽤就是通过域名查询到具体的 IP。</p><p>因为 IP 存在数字和英⽂的组合（IPv6），很不利于⼈类记忆，所以就出现了域名。你可以把 域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p><p>**在 TCP 握⼿之前就已经进⾏了 DNS 查询，这个查询是操作系统⾃⼰做的。**当你在浏览器中 想访问 www.google.com 时，会进⾏⼀下操作：</p><ol><li>操作系统会⾸先在本地缓存中查询</li><li>没有的话会去系统配置的 DNS 服务器中查询</li><li>如果这时候还没得话，会直接去 DNS 根服务器查询，这⼀步查询会找出负责 com 这个⼀级域名的服务器</li><li>然后去该服务器查询 google 这个⼆级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置⼀个 IP，然后还可以给别的三级域名配置⼀个 IP</li></ol><p>以上介绍的是 DNS <strong>迭代查询</strong>，还有种是递归查询，区别就是前者是由客户端去做请求，后者是系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。</p><p>PS：<strong>DNS 是基于 UDP 做的查询。</strong></p><h3 id="从输入-url-到⻚面加载完成的过程" tabindex="-1"><a class="header-anchor" href="#从输入-url-到⻚面加载完成的过程" aria-hidden="true">#</a> 从输⼊ URL 到⻚⾯加载完成的过程 ⭐</h3><p>这是⼀个很经典的⾯试题，在这题中可以将本⽂讲得内容都串联起来。</p><ol><li><p>⾸先做 DNS 查询，如果这⼀步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来。</p></li><li><p><strong>接下来是 TCP 握⼿</strong>，应⽤层会下发数据给传输层，这⾥ TCP 协议会指明两端的端⼝号，然后下发给⽹络层。⽹络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层⾯的传输了。</p></li><li><p>TCP 握⼿结束后会进⾏ <strong>TLS 握⼿</strong>，然后就开始正式的传输数据。</p></li><li><p>数据在进⼊服务端之前，可能还会先经过负责负载均衡的服务器，它的作⽤就是将请求合理的分发到多台服务器上，这时假设服务端会响应⼀个 HTML ⽂件</p></li><li><p>⾸先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进⾏重定向，这⾥会有个重定向计数器，避免过多次的重定向，超过次数也会报错。</p></li><li><p>浏览器开始解析⽂件，如果是 gzip 格式的话会先解压⼀下，然后通过⽂件的编码格式知道该如何去解码⽂件。</p></li><li><p>⽂件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer，前者会并⾏进⾏下载并执⾏ JS，后者会先下载⽂件，然后等待 HTML 解析完成后顺序执⾏，如果以上都没有，就会阻塞住渲染流程直到 JS 执⾏完毕。遇到⽂件下载的会去下 载⽂件，这⾥如果使⽤ HTTP 2.0 协议的话会极⼤的提⾼多图的下载效率。</p></li><li><p>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</p></li><li><p>CSSOM 树和 DOM 树构建完成后会开始⽣成 Render 树，这⼀步就是确定⻚⾯元素的布局、样式等等诸多⽅⾯的东⻄</p></li><li><p>在⽣成 Render 树的过程中，浏览器就开始调⽤ GPU 绘制，合成图层，将内容显示在屏幕上了</p></li></ol><h2 id="数据结构章节" tabindex="-1"><a class="header-anchor" href="#数据结构章节" aria-hidden="true">#</a> 数据结构章节</h2><p>科班就略了哈....</p>`,167);function u(s,r){return t(),p("div",null,[c,e("p",null,"在解析如上模板代码时，遇到 "+o(s.name)+" 就会给属性 name 添加发布订阅。",1),l])}const m=a(i,[["render",u],["__file","前端面试十万字书籍总结.html.vue"]]);export{m as default};
