import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as o,a as e,b as i,d as a,e as s,r as l}from"./app.d7b34baa.js";const p={},d=s('<h1 id="同构渲染-ssr-server-side-rendering-与csh-client-side-hydration" tabindex="-1"><a class="header-anchor" href="#同构渲染-ssr-server-side-rendering-与csh-client-side-hydration" aria-hidden="true">#</a> 同构渲染：SSR (Server-Side Rendering) 与CSH (Client-Side Hydration)</h1><h2 id="什么是同构渲染" tabindex="-1"><a class="header-anchor" href="#什么是同构渲染" aria-hidden="true">#</a> 什么是同构渲染？</h2><p>同构（Isomorphic） JavaScript，通常称为通用（Universal）JavaScript，在服务器端和客户端均渲染。在这种呈现方法下，预渲染用于向搜索引擎或用户提供的内容。之后，JavaScript 所需的交互内容在客户端处理。</p><p>同构 JavaScript 意味着应用程序在服务器和客户端上使用类似的渲染引擎。这种呈现方法使开发人员更容易维护标记模板，从而简化了 Web 开发。</p><p>同构渲染意味着使用 Node.js 和 JavaScript，因为它们允许重用库，并使浏览 JavaScript 代码能够在 Node.js 环境中运行，而无需进行太多修改。Node.js 和 JavaScript 在编码生态系统中的这种互换性可以支持几种不同的同构框架，如React.js等。</p><p>实际上，简单来说就是一份代码，服务端先通过服务端渲染(server-side rendering，下称SSR)，生成HTML以及初始化数据，客户端拿到代码和初始化数据后，通过对HTML的dom进行patch和事件绑定来对dom进行客户端激活(client-side hydration，下称CSH)，这个整体的过程叫同构渲染。其实就是满足三个条件：</p><ol><li>同一份代码</li><li>SSR</li><li>CSR</li></ol><h2 id="单说ssr" tabindex="-1"><a class="header-anchor" href="#单说ssr" aria-hidden="true">#</a> 单说SSR</h2><p>“服务端渲染”一词在前端框架盛行之前并未被提及，但它确实存在。比如.php文件就直接支持用语法来渲染HTML，还包括java的JSP技术等。</p><h2 id="与传统php-jsp渲染有什么不同-算得上是ssr吗" tabindex="-1"><a class="header-anchor" href="#与传统php-jsp渲染有什么不同-算得上是ssr吗" aria-hidden="true">#</a> 与传统PHP，JSP渲染有什么不同？算得上是SSR吗？</h2><p>既然同构渲染就是一份代码SSR加CSH，那么SSR部分本质上跟php，jsp也是一样，也就是模版引擎出来HTML字符串，但是同构要求能通过一份代码实现SSR，CSH，同时服务端需要提供一份初始化数据以便CSH，而且传统php，jsp不关注CSH过程。这三点就是与传统SSR的区别</p><h2 id="同构方法的优点" tabindex="-1"><a class="header-anchor" href="#同构方法的优点" aria-hidden="true">#</a> 同构方法的优点</h2><p>同构处理的优点可以分为两个方面。</p><ul><li><p><strong>功能方面</strong></p><ul><li>代码在应用程序的前端和后端之间共享。</li></ul></li><li><p>加载时间更快，并自动支持旧版浏览器。</p></li><li><p><strong>技术方面</strong></p><ul><li>开发人员将需要学习更少的语言。</li></ul></li><li><p>该库将能够与自身集成。</p></li><li><p>服务器在加载初始页面时呈现 HTML。</p></li><li><p>数据以一致的数据格式存储。</p></li><li><p>开发人员将不得不编写和维护更少的代码。</p></li></ul><h2 id="同构方法的缺点" tabindex="-1"><a class="header-anchor" href="#同构方法的缺点" aria-hidden="true">#</a> 同构方法的缺点</h2><p>同构处理有一些缺点：</p><ul><li>由于应用程序的体系结构复杂，故障排除更具有挑战性。</li><li>敏感数据更容易暴露。</li><li>整个应用程序的体系结构变得更加复杂。</li></ul>',17),h=e("p",null,[e("strong",null,"参考：")],-1),c={href:"https://medium.com/capital-one-tech/why-everyone-is-talking-about-isomorphic-universal-javascript-and-why-it-matters-38c07c87905",target:"_blank",rel:"noopener noreferrer"},S={href:"https://prerender.io/blog/isomorphic-rendering/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://en.wikipedia.org/wiki/Isomorphic_JavaScript",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.zhihu.com/question/325952676/answer/694270730",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.css3.io/isomorphic-Is-not-perfect-as-you-think.html",target:"_blank",rel:"noopener noreferrer"};function v(f,g){const r=l("ExternalLinkIcon");return t(),o("div",null,[d,e("blockquote",null,[h,e("p",null,[e("a",c,[i("Why Everyone is Talking About Isomorphic / Universal JavaScript and Why it Matters | by Azat Mardan | Capital One Tech | Medium"),a(r)])]),e("p",null,[e("a",S,[i("Isomorphic Rendering vs. Dynamic Rendering for JavaScript"),a(r)])]),e("p",null,[e("a",_,[i("Isomorphic JavaScript - Wikipedia"),a(r)])]),e("p",null,[e("a",u,[i("什么是前端的同构渲染？"),a(r)])]),e("p",null,[e("a",m,[i("同构并非想象中完美"),a(r)])])])])}const H=n(p,[["render",v],["__file","同构渲染：SSR (Server-Side Rendering) 与CSH (Client-Side Hydration).html.vue"]]);export{H as default};
