import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as a,e as p}from"./app.d7b34baa.js";const t={},e=p(`<h1 id="node-js-进程通信" tabindex="-1"><a class="header-anchor" href="#node-js-进程通信" aria-hidden="true">#</a> Node.js 进程通信</h1><blockquote><p>由面试题引出的</p></blockquote><p>黄金时代：事件驱动</p><p>为了解决高并发问题，基于事件驱动的服务模型出现了，像Node与Nginx均是基于事件驱动 的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。</p><h2 id="多进程架构" tabindex="-1"><a class="header-anchor" href="#多进程架构" aria-hidden="true">#</a> 多进程架构</h2><p>面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个 进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了child_process模块，并 且也提供了child_process.fork()函数供我们实现进程的复制。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;http&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string-property property">&#39;Content-Type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;text/plain&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;Hello World\\n&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&#39;127.0.0.1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>node worker.js</code>启动它，将会侦听1000到2000之间的一个随机端口。</p><p>将以下代码存为master.js，并通过node master.js启动它：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> fork <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fork<span class="token punctuation">;</span>
<span class="token keyword">var</span> cpus <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;os&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cpus<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">&#39;./worker.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码将会根据当前机器上的CPU数量复制出对应Node进程数。在*nix系统下可以通过ps aux | grep worker.js查看到进程的数量，如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> worker.js
jacksontian <span class="token number">1475</span> <span class="token number">0.0</span> <span class="token number">0.0</span> <span class="token number">2432768</span> <span class="token number">600</span> s003 S+ <span class="token number">3</span>:27AM <span class="token number">0</span>:00.00 <span class="token function">grep</span> worker.js
jacksontian <span class="token number">1440</span> <span class="token number">0.0</span> <span class="token number">0.2</span> <span class="token number">3022452</span> <span class="token number">12680</span> s003 S <span class="token number">3</span>:25AM <span class="token number">0</span>:00.14 /usr/local/bin/node ./worker.js
jacksontian <span class="token number">1439</span> <span class="token number">0.0</span> <span class="token number">0.2</span> <span class="token number">3023476</span> <span class="token number">12716</span> s003 S <span class="token number">3</span>:25AM <span class="token number">0</span>:00.14 /usr/local/bin/node ./worker.js
jacksontian <span class="token number">1438</span> <span class="token number">0.0</span> <span class="token number">0.2</span> <span class="token number">3022452</span> <span class="token number">12704</span> s003 S <span class="token number">3</span>:25AM <span class="token number">0</span>:00.14 /usr/local/bin/node ./worker.js
jacksontian <span class="token number">1437</span> <span class="token number">0.0</span> <span class="token number">0.2</span> <span class="token number">3031668</span> <span class="token number">12696</span> s003 S <span class="token number">3</span>:25AM <span class="token number">0</span>:00.15 /usr/local/bin/node ./worker.js 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是著名的Master-Worker模式，又称主从模式。图中的进程分为两种：主进程和工作进程。这是典型的分式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204062214585.png" alt="image-20220406221417509"></p><h3 id="创建子进程" tabindex="-1"><a class="header-anchor" href="#创建子进程" aria-hidden="true">#</a> 创建子进程</h3><h3 id="进程间通信" tabindex="-1"><a class="header-anchor" href="#进程间通信" aria-hidden="true">#</a> 进程间通信</h3><p>在Master-Worker模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于child_process模块，创建好了子进程，然后与父子进程间通信是十分容易的。</p><p>在前端浏览器中，**JavaScript主线程与UI渲染共用同一个线程。执行JavaScript的时候UI渲染 是停滞的，渲染UI时，JavaScript是停滞的，两者互相阻塞。**长时间执行JavaScript将会造成UI停 顿不响应。为了解决这个问题，HTML5提出了WebWorker API。WebWorker允许创建工作线程并 在后台运行，使得一些阻塞较为严重的计算不影响主线程上的UI渲染。</p><p>Node中对应示例如下所示：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// parent.js</span>
<span class="token keyword">var</span> cp <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> n <span class="token operator">=</span> cp<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">&#39;/sub.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
n<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;message&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;PARENT got message:&#39;</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
n<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">hello</span><span class="token operator">:</span> <span class="token string">&#39;world&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// sub.js</span>
process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;message&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;CHILD got message:&#39;</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进 程之间将会**<u>创建IPC通道</u>**。通过IPC通道，父子进程之间才能通过message和send()传递消息。</p><ul><li>进程间通信原理</li></ul><p>IPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同 的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如<strong>命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket</strong>等。Node中实现IPC通道的是**<u>管道（pipe） 技术</u><em><em>。但此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，<em><em>在 Windows下由<u>命名管道</u>（named pipe）实现，<em>nix系统则采用Unix Domain <u>Socket</u>实现</em></em>。</em></em><u>表现在应用层上</u><strong>的进程间通信</strong><u>只有简单的message事件和send()方法</u></em>*，接口十分简洁和消息化。图9-2为IPC 创建和实现的示意图。</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204062226499.png" alt="image-20220406222630302"></p><p>父进程<strong>在实际创建子进程之前，会创建IPC通道并监听它(中间者)</strong>，然后才真正创建出子进程，并通 过环境变量（NODE_CHANNEL_FD）<strong>告诉子进程这个IPC通道的文件描述符</strong>。子进程在启动的过程中， 根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。图9-3为创建IPC 管道的步骤示意图。</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204062231266.png" alt="image-20220406223102209"></p><p>建立连接之后的父子进程就可以自由地通信了。由于IPC通道是用命名管道或Domain Socket创建的，它们与网络socket的行为比较类似，<strong>属于双向通信</strong>。<strong>不同的是它们在<u>系统内核</u>中就完成了进程间的通信</strong>，而不用经过实际的网络层，非常高效。在Node中，IPC通道被抽象为Stream（流）对象，在调用send()时发送数据（类似于write()），接收到的消息会通过message事件（类似于data）触发给应用层。</p>`,27),o=[e];function c(u,l){return s(),a("div",null,o)}const k=n(t,[["render",c],["__file","Node.js 进程通信.html.vue"]]);export{k as default};
