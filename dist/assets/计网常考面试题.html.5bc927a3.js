import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as r,e}from"./app.d7b34baa.js";const t={},s=e('<h1 id="计网常考面试题" tabindex="-1"><a class="header-anchor" href="#计网常考面试题" aria-hidden="true">#</a> 计网常考面试题</h1><blockquote><p>参照</p><p>https://juejin.cn/post/6989567548765241381</p><p>https://blog.csdn.net/sangjinchao/article/details/79852670</p></blockquote><h2 id="_1、为什么tcp连接的时候是3次-2次不可以吗" tabindex="-1"><a class="header-anchor" href="#_1、为什么tcp连接的时候是3次-2次不可以吗" aria-hidden="true">#</a> 1、为什么TCP连接的时候是3次？2次不可以吗？</h2><h3 id="考虑丢包问题-保证全双工" tabindex="-1"><a class="header-anchor" href="#考虑丢包问题-保证全双工" aria-hidden="true">#</a> 考虑丢包问题（保证全双工）</h3><ol><li>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</li><li>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</li></ol><h3 id="保证序列号双方确认" tabindex="-1"><a class="header-anchor" href="#保证序列号双方确认" aria-hidden="true">#</a> 保证序列号双方确认</h3><ol><li>为了实现可靠数据传输， <strong>TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是<u>通信双方相互告知序列号起始值</u>， 并确认对方已经收到了序列号起始值的必经步骤</strong></li><li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li></ol><h2 id="_2、为什么tcp连接的时候是3次-关闭的时候却是4次" tabindex="-1"><a class="header-anchor" href="#_2、为什么tcp连接的时候是3次-关闭的时候却是4次" aria-hidden="true">#</a> 2、为什么TCP连接的时候是3次，关闭的时候却是4次？</h2><p><u>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP</u>。<strong>而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的</strong>。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我<strong>服务端还有一些数据没发完，等这些数据发完了</strong>服务端才能给客户端发FIN报文(所以<u>不能一次性将确认报文和FIN报文发给客户端</u>，就是这里多出来了一次)。</p><h2 id="_3、为什么客户端发出第四次挥手的确认报文后要等2msl的时间才能释放tcp连接" tabindex="-1"><a class="header-anchor" href="#_3、为什么客户端发出第四次挥手的确认报文后要等2msl的时间才能释放tcp连接" aria-hidden="true">#</a> 3、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h2><p>这里同样是要考虑丢包的问题，<strong>如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL</strong>，所以需要等这么长时间来确认服务端确实已经收到了。</p><h2 id="_4、如果已经建立了连接-但是客户端突然出现故障了怎么办" tabindex="-1"><a class="header-anchor" href="#_4、如果已经建立了连接-但是客户端突然出现故障了怎么办" aria-hidden="true">#</a> 4、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个<strong>保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会<strong>发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</strong></p><h2 id="_5、time-wait过多会出现什么问题" tabindex="-1"><a class="header-anchor" href="#_5、time-wait过多会出现什么问题" aria-hidden="true">#</a> 5、time wait过多会出现什么问题</h2><blockquote><p>time-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，也就是ACK=1的信号结束后，主动关闭连接方所处的状态。</p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/image-20220331203539095.png" alt="image-20220331203539095" style="zoom:67%;"></blockquote><p>对于网站来说，这样的time_wait略显偏高, 也就是说大量的关闭操作在等待2个MSL后结束，正常我们的tcp 端口是65535个，如果并发再高一些，可能会<strong>大量的socket不能及时被释放，从而导致性能下降</strong>，</p><p>在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。<strong>如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</strong></p><p>所以我们<strong>可以通过linux内核进行一些网络调整比如，开启socket重用和快速回收</strong></p><h2 id="_6、close-wait-过多会出现什么问题" tabindex="-1"><a class="header-anchor" href="#_6、close-wait-过多会出现什么问题" aria-hidden="true">#</a> 6、CLOSE_WAIT 过多会出现什么问题？</h2><p><strong>CLOSE_WAIT 过多导致服务器资源占用</strong>，客户端在 FIN_WAIT_2 状态超时大约 60s，自动进入 CLOSED状态， 影响不大。但是**服务端在 CLOSE_WAIT 的超时时间默认为 43200秒，所以大量的 CLOSE_WAIT 积压可能造成服务器无法分配出资源给新的连接。*<em>一般这种情况都是*<em>由于服务器没有调用 close 造成的。程序员应该主动检查代码。</em></em></p><h2 id="_7、什么是http、https" tabindex="-1"><a class="header-anchor" href="#_7、什么是http、https" aria-hidden="true">#</a> 7、什么是HTTP、HTTPS？</h2><ol><li>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</li></ol><ul><li><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口<strong>80</strong>，而HTTPS的URL由“https://”起始且默认使用端口<strong>443。</strong></li><li>**安全性和资源消耗：**HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li></ul><ol><li><strong>HTTPS中的S表示SSL或者TLS，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层</strong>。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。<strong>所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密</strong>。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</li></ol><ul><li><strong>对称加密：密钥只有一个，加密解密为同一个密码</strong>，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密： 加密和解密使用不同的密钥，这两个密钥形成有且仅有唯一的配对，叫公钥和私钥。<strong>数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密</strong>，相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul><h2 id="_8、http-与-https-的区别" tabindex="-1"><a class="header-anchor" href="#_8、http-与-https-的区别" aria-hidden="true">#</a> 8、HTTP 与 HTTPS 的区别？</h2><ul><li><strong>https协议需要到ca申请证书，一般免费证书很少，需要交费。</strong></li><li><strong>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</strong></li><li><strong>http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。</strong></li><li><strong>http的连接很简单,是无状态的 。</strong></li><li><strong>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议， 要比http协议安全。</strong></li></ul><h2 id="_9、get和post区别" tabindex="-1"><a class="header-anchor" href="#_9、get和post区别" aria-hidden="true">#</a> 9、GET和POST区别？</h2><p>浏览器和服务器的交互是通过HTTP协议执行的，HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。而GET和POST也是HTTP协议中的两种方法。</p><ul><li><strong>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</strong></li><li><strong>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</strong></li></ul><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h3><ul><li><p>**get 方法一般用于请求，**比如你在浏览器地址栏输入 <code>www.cxuanblog.com</code> 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 <strong>post 方法一般用于```表单`的提交，相当于是把信息提交给服务器，等待服务器作出响应</strong>，get 相当于一个是 pull/拉的操作，而 post 相当于是一个 push/推的操作。</p></li><li><p><strong>get 方法是不安全的</strong>，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；而 <strong>post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</strong></p></li><li><p>**get 请求的 URL 有长度限制，<strong>这个限制是</strong>浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。**而 post 请求会把参数和值放在消息体中，对数据长度没有要求。</p></li><li><p>get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。</p></li><li><p><strong>get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包</strong>。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，<strong>浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok</strong>（返回数据）。</p></li></ul><h2 id="_10、浏览器关闭后-session还可以用吗" tabindex="-1"><a class="header-anchor" href="#_10、浏览器关闭后-session还可以用吗" aria-hidden="true">#</a> 10、浏览器关闭后,session还可以用吗</h2><p><strong>当我们重新打开浏览器窗口时，之前的Cookie中存放的Sessionid已经不存在了，此时</strong></p><p><strong>服务器从HttpServletRequest对象中没有检查到sessionid，服务器会再发送一个新的存</strong></p><p><strong>有Sessionid的Cookie到客户端的浏览器中，此时对应的是一个新的会话，而服务器上</strong></p><p><strong>原先的session等到它的默认时间到之后，便会自动销毁。</strong></p><p>当在同一个浏览器中同时打开多个标签，发送同一个请求或不同的请求，仍是同一个session;</p><p>当不在同一个窗口中打开相同的浏览器时，发送请求，仍是同一个session;</p><p>当使用不同的浏览器时，发送请求，即使发送相同的请求，是不同的session;</p><h2 id="_11、如果客户端禁止-cookie-能实现-session-还能用吗" tabindex="-1"><a class="header-anchor" href="#_11、如果客户端禁止-cookie-能实现-session-还能用吗" aria-hidden="true">#</a> 11、如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</p><p>但为什么禁用Cookie就不能得到Session呢？<strong>因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</strong></p><p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p><ul><li><strong>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</strong></li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用</li></ul><h2 id="_12、介绍下了解的通信协议" tabindex="-1"><a class="header-anchor" href="#_12、介绍下了解的通信协议" aria-hidden="true">#</a> 12、介绍下了解的通信协议？</h2><p>FTP 文件传输协议（File Transfer Protocol）</p><p>SMTP：邮件传送协议，</p><p>ARP 协议是正向地址解析协议（Address Resolution Protocol），通过已知的 IP，寻找对应主机的 MAC 地址</p><p>RARP 协议是返向地址解析协议（逆地址解析），通过 MAC 地址确定 IP地址</p><h2 id="_13、什么是arp-rarp协议" tabindex="-1"><a class="header-anchor" href="#_13、什么是arp-rarp协议" aria-hidden="true">#</a> 13、什么是ARP/RARP协议？</h2><p>**地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。**主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><h2 id="_14、地址栏输入-url-发生了什么" tabindex="-1"><a class="header-anchor" href="#_14、地址栏输入-url-发生了什么" aria-hidden="true">#</a> 14、地址栏输入 URL 发生了什么</h2><blockquote><p>常考面试题，回答注意两点，1是注意回答的条理性，2是注意回答内容尽量详细，展现知识的宽度和深度</p></blockquote><ul><li><p>首先，你需要在浏览器中的 URL 地址上，输入你想访问的地址，比如www.baidu.com</p></li><li><p>然后，浏览器会根据你输入的 URL 地址，<strong>去查找域名是否被本地 DNS 缓存</strong>，<strong>不同浏览器对 DNS 的设置不同，如果浏览器缓存了你想访问的 URL 地址，那就直接返回 ip。如果没有缓存你的 URL 地址，浏览器就会发起系统调用来查询本机 <code>hosts</code> 文件是否有配置 ip 地址，如果找到，直接返回。如果找不到，就向网络中发起一个 DNS 查询。在由根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威 DNS 服务器后，由权威服务器告诉本地服务器目标 IP 地址，再有本地 DNS 服务器告诉用户需要访问的 IP 地址。</strong></p></li><li><blockquote><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。</p></blockquote></li><li><p>第三步，浏览器需要和目标服务器建立 TCP 连接，需要经过三次握手的过程，TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><ul><li><strong>1. 应用层：发送 HTTP 请求</strong></li><li>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括： <ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul></li><li>\\2. 传输层：TCP 传输报文 <ul><li>传输层会发起一条到达服务器的 TCP 连接**，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。**</li></ul></li><li>\\3. 网络层：IP协议查询Mac地址 <ul><li>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</li><li>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</li></ul></li><li><strong>4. 链路层：以太网协议</strong></li></ul></li><li><p>在建立连接后，浏览器会向目标服务器发起 <code>HTTP-GET</code> 请求，包括其中的 URL，<strong>HTTP 1.1 后默认使用长连接，只需要一次握手即可多次传输数据。</strong></p></li><li><p>如果目标服务器只是一个简单的页面，就会直接返回。但是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而会直接重定向。返回的状态码就不是 200 ，而是 301,302 以 3 开头的重定向码，<strong>浏览器在获取了重定向响应后，在响应报文中 Location 项找到重定向地址，浏览器重新第一步访问即可</strong>。</p></li><li><p>然后浏览器重新发送请求，携带新的 URL，返回状态码 200 OK，表示服务器可以响应请求，返回报文。</p></li><li><p><strong>渲染页面</strong></p></li></ul><h2 id="_15、中间人有可能篡改该证书吗" tabindex="-1"><a class="header-anchor" href="#_15、中间人有可能篡改该证书吗" aria-hidden="true">#</a> 15、中间人有可能篡改该证书吗？</h2><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。<strong>浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信</strong>，从而终止向服务器传输信息，防止信息泄露给中间人。</p><h2 id="_16、中间人有可能把证书掉包吗" tabindex="-1"><a class="header-anchor" href="#_16、中间人有可能把证书掉包吗" aria-hidden="true">#</a> 16、中间人有可能把证书掉包吗？</h2><ol><li>假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。</li><li>其实这并不会发生，<strong>因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了</strong>。</li></ol><h2 id="_17、为什么制作数字签名时需要hash一次" tabindex="-1"><a class="header-anchor" href="#_17、为什么制作数字签名时需要hash一次" aria-hidden="true">#</a> 17、为什么制作数字签名时需要hash一次？</h2><blockquote><p>我初学HTTPS的时候就有这个问题，似乎以上过程中hash有点多余，把hash过程去掉也能保证证书没有被篡改。</p></blockquote><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。</p><h2 id="_18、http协议实现了什么" tabindex="-1"><a class="header-anchor" href="#_18、http协议实现了什么" aria-hidden="true">#</a> 18、http协议实现了什么？</h2><ol><li>客户与服务器建立连接tcp</li><li>客户向服务器提出请求</li><li>服务器接受请求，并根据请求返回相应的文件作为应答</li><li>客户与服务器关闭连接。</li></ol><h2 id="_19、什么是无状态协议-http-是无状态协议吗-怎么解决" tabindex="-1"><a class="header-anchor" href="#_19、什么是无状态协议-http-是无状态协议吗-怎么解决" aria-hidden="true">#</a> 19、什么是无状态协议，HTTP 是无状态协议吗，怎么解决？</h2><ol><li>无状态协议(Stateless Protocol) 就是指<strong>浏览器对于事务的处理没有记忆能力</strong>。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，<strong>但是服务器并不知道客户关闭了一次浏览器。</strong></li><li><strong>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力</strong>。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 <strong>小甜饼(Cookie)的机制。它能够让浏览器具有记忆能力。</strong></li><li>那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态<strong>session登录的认证方案是看，用户从客户端传递用户名和密码登录信息，服务端认证后将信息储存在session中，将session_id放入cookie中，以后访问其他页面，服务器都会带着cookie，服务端会自动从cookie中获取session_id,在从session中获取认证信息。</strong></li><li>**在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。*<em>既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是*<em>通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</em></em></li></ol><h2 id="_20、为什么使用非对称加密和对称加密" tabindex="-1"><a class="header-anchor" href="#_20、为什么使用非对称加密和对称加密" aria-hidden="true">#</a> 20、为什么使用非对称加密和对称加密？</h2><p>对称加密的问题在于<strong>这个密钥怎么让传输的双方知晓，同时不被别人知道</strong>，依赖于非对称加密将秘钥进行传输，非对称加密耗时，所以采用非对称加密和对称加密组合的方式</p><h2 id="_21、tcp粘包是什么" tabindex="-1"><a class="header-anchor" href="#_21、tcp粘包是什么" aria-hidden="true">#</a> 21、TCP粘包是什么？</h2><p><strong>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</strong></p><h2 id="_22、什么时候需要考虑粘包问题" tabindex="-1"><a class="header-anchor" href="#_22、什么时候需要考虑粘包问题" aria-hidden="true">#</a> 22、什么时候需要考虑粘包问题？</h2><ol><li><strong>如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题</strong>（因为只有一种包结构,类似于http协议）。</li></ol><ul><li>关闭连接主要是要双方都发送close连接（参考tcp关闭协议）。如：A需要发送一段字符串给B，那么A与B建立连接，然后发送双方都默认好的协议字符如&quot;hello give me sth abour yourself&quot;，然后B收到报文后，就将缓冲区数据接收，然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。</li></ul><ol><li><strong>如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包</strong></li><li>如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构，一般可能会在头加一个数据长度之类的包，以确保接收</li></ol><h2 id="_23、粘包出现原因" tabindex="-1"><a class="header-anchor" href="#_23、粘包出现原因" aria-hidden="true">#</a> 23、粘包出现原因？</h2><p>出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。简单得说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong>(参考Windows网络编程)</p><ol><li><strong>发送端需要等缓冲区满才发送出去，造成粘包</strong></li><li><strong>接收方不及时接收缓冲区的包，造成多个包接收</strong></li></ol><p>具体来讲：</p><ol><li>发送方引起的粘包是由TCP协议本身造成的，<strong>TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</strong></li><li>接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，<strong>若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后</strong>，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</li><li><strong>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</strong></li><li>不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。</li><li>在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结构数据的粘包问题时，分包算法就比较复杂。特别是粘在一起的包有不完整的包的粘包情况，<strong>由于一包数据内容被分在了两个连续的接收包中</strong>，处理起来难度较大。<strong>实际工程应用中应尽量避免出现粘包现象。</strong></li></ol><h2 id="_24、如何避免粘包问题" tabindex="-1"><a class="header-anchor" href="#_24、如何避免粘包问题" aria-hidden="true">#</a> 24、如何避免粘包问题？</h2><ol><li><strong>对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push</strong>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li><li><strong>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据</strong>，从而尽量避免出现粘包现象；</li><li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</li></ol><h4 id="以上提到的三种措施-都有其不足之处。" tabindex="-1"><a class="header-anchor" href="#以上提到的三种措施-都有其不足之处。" aria-hidden="true">#</a> 以上提到的三种措施，都有其不足之处。</h4><ol><li>第一种编程设置方法虽然可以避免发送方引起的粘包，<strong>但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</strong></li><li><strong>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包</strong>。</li><li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ol><p><strong>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。</strong></p><h2 id="_25、讲一讲拆包" tabindex="-1"><a class="header-anchor" href="#_25、讲一讲拆包" aria-hidden="true">#</a> 25、讲一讲拆包？</h2><p>对于拆包目前最常用的是以下两种方式：</p><h4 id="_1、动态缓冲区暂存方式。" tabindex="-1"><a class="header-anchor" href="#_1、动态缓冲区暂存方式。" aria-hidden="true">#</a> 1、动态缓冲区暂存方式。</h4><p>之所以说缓冲区是动态的是因为<strong>当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度</strong>。大概过程描述如下:</p><ol><li>为每一个连接动态分配一个缓冲区,同时把此缓冲区和SOCKET关联,常用的是通过结构体关联.</li><li>当接收到数据时首先把此段数据存放在缓冲区中.</li><li><strong>判断缓存区中的数据长度是否够一个包头的长度,如不够,则不进行拆包操作.</strong></li><li>根据包头数据解析出里面代表包体长度的变量.</li><li><strong>判断缓存区中除包头外的数据长度是否够一个包体的长度,如不够,则不进行拆包操作.</strong></li><li>取出整个数据包.这里的&quot;取&quot;的意思是不光<strong>从缓冲区中拷贝出数据包,而且要把此数据包从缓存区中删除掉.删除的办法就是把此包后面的数据移动到缓冲区的起始地址.</strong></li></ol><p>这种方法有两个缺点：</p><ol><li>为每个连接动态分配一个缓冲区增大了内存的使用.</li><li>有三个地方需要拷贝数据,一个地方是把数据存放在缓冲区,一个地方是把完整的数据包从缓冲区取出来,一个地方是把数据包从缓冲区中删除.第二种拆包的方法会解决和完善这些缺点.</li></ol><p>可以采用环形缓冲进行改善，环形缓冲实现方案是定义两个指针,分别指向有效数据的头和尾.在存放数据和删除数据时只是进行头尾指针的移动。但是这种改进方法还是不能解决第一个缺点以及第一个数据拷贝,只能解决第三个地方的数据拷贝(这个地方是拷贝数据最多的地方).第2种拆包方式会解决这两个问题.</p><h4 id="_2、利用底层的缓冲区来进行拆包" tabindex="-1"><a class="header-anchor" href="#_2、利用底层的缓冲区来进行拆包" aria-hidden="true">#</a> 2、利用底层的缓冲区来进行拆包</h4><ol><li>由于<strong>TCP也维护了一个缓冲区,所以我们完全可以利用TCP的缓冲区来缓存我们的数据</strong>，这样一来就不需要为每一个连接分配一个缓冲区了。另一方面我们知道recv或者wsarecv都有一个参数,用来表示我们要接收多长长度的数据。利用这两个条件我们就可以对第一种方法进行优化。</li><li>对于阻塞SOCKET来说，我们可以利用一个循环来接收包头长度的数据，然后解析出代表包体长度的那个变量，再用一个循环来接收包体长度的数据。</li></ol><h3 id="_26、讲一下http-请求页面的过程" tabindex="-1"><a class="header-anchor" href="#_26、讲一下http-请求页面的过程" aria-hidden="true">#</a> 26、讲一下HTTP 请求页面的过程？</h3><ul><li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li><li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li><li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li><li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li><li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li><li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li></ul><h2 id="_27、有哪些方面的因素会导致网站访问慢" tabindex="-1"><a class="header-anchor" href="#_27、有哪些方面的因素会导致网站访问慢" aria-hidden="true">#</a> 27、有哪些方面的因素会导致网站访问慢？</h2><h3 id="_1-服务器出口带宽不够用" tabindex="-1"><a class="header-anchor" href="#_1-服务器出口带宽不够用" aria-hidden="true">#</a> 1. 服务器出口带宽不够用</h3><ol><li>本身服务器购买的出口带宽比较**。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。**</li><li><strong>跨运营商网络导致带宽缩减</strong>。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li></ol><h3 id="_2-服务器负载过大-导致响应不过来" tabindex="-1"><a class="header-anchor" href="#_2-服务器负载过大-导致响应不过来" aria-hidden="true">#</a> 2. 服务器负载过大，导致响应不过来</h3><p>可以从两个方面入手分析：</p><ol><li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li><li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li></ol><h3 id="_3-数据库瓶颈" tabindex="-1"><a class="header-anchor" href="#_3-数据库瓶颈" aria-hidden="true">#</a> 3. 数据库瓶颈</h3><ol><li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li><li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li></ol><h3 id="_4-网站开发代码没有优化好" tabindex="-1"><a class="header-anchor" href="#_4-网站开发代码没有优化好" aria-hidden="true">#</a> 4. 网站开发代码没有优化好</h3><p>例如 SQL 语句没有优化，导致数据库读写相当耗时。</p><h2 id="_28、针对网站访问慢-怎么去排查" tabindex="-1"><a class="header-anchor" href="#_28、针对网站访问慢-怎么去排查" aria-hidden="true">#</a> 28、针对网站访问慢，怎么去排查？</h2><ol><li>**首先要确定是用户端还是服务端的问题。**当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</li></ol><blockquote><p><strong>不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</strong></p></blockquote><ol><li>如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</li><li>**针对服务器负载情况。 ** <strong>查看服务器硬件(网络、CPU、内存)的消耗情况</strong>。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</li><li><strong>如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</strong></li></ol><h2 id="_29、怎么去解决访问慢问题" tabindex="-1"><a class="header-anchor" href="#_29、怎么去解决访问慢问题" aria-hidden="true">#</a> 29、怎么去解决访问慢问题？</h2><ol><li>如果是出口带宽问题，那么久申请加大出口带宽。</li><li><strong>如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化</strong>。</li><li><strong>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等</strong>等。然后<strong>也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</strong></li><li>申请购买 CDN 服务，加载用户的访问。</li><li>如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</li></ol><h2 id="_31、常见应用层协议" tabindex="-1"><a class="header-anchor" href="#_31、常见应用层协议" aria-hidden="true">#</a> 31、常见应用层协议</h2><h3 id="使用udp的" tabindex="-1"><a class="header-anchor" href="#使用udp的" aria-hidden="true">#</a> 使用UDP的</h3><ul><li>TFTP（Trivial File Transfer Protocol,简单文件传输协议）</li><li>DNS（Domain Name System，域名系统）</li></ul><h3 id="使用tcp的" tabindex="-1"><a class="header-anchor" href="#使用tcp的" aria-hidden="true">#</a> 使用TCP的</h3><ul><li>超文本传输协议（HTTP，HyperText Transfer Protocol)</li><li>SSL(Secure Sockets Layer <strong>安全套接层</strong>),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。</li><li>FTP是文件传送协议,基于tcp的使用tcp 20和21号端口</li><li>SFTP是Secure File Transfer Protocol的缩写，是安全文件传送协议。</li><li>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。</li><li>POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。POP3协议默认端口：110 POP3协议默认传输协议：TCP POP3协议适用的构架结构：C/S POP3协议的访问模式：<strong>离线访问</strong></li></ul>',118),a=[s];function l(n,h){return o(),r("div",null,a)}const c=i(t,[["render",l],["__file","计网常考面试题.html.vue"]]);export{c as default};
