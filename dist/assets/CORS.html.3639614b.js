import{_ as r}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as l,a as e,b as o,d as c,e as d,r as n}from"./app.d7b34baa.js";const s={},i=e("h1",{id:"cors-简单请求-预检请求",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#cors-简单请求-预检请求","aria-hidden":"true"},"#"),o(" CORS 简单请求+预检请求")],-1),p=e("blockquote",null,[e("p",null,"参照："),e("p",null,"https://github.com/amandakelake/blog/issues/62")],-1),h=e("code",null,"域、协议、端口",-1),u={href:"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy",target:"_blank",rel:"noopener noreferrer"},g=d('<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求，XMLHttpRequest和Fetch API，只能从加载应用程序的同一个域请求HTTP资源，除非使用<code>CORS头文件</code></p><p>对于<strong>浏览器限制</strong>这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了</p><h2 id="cors概述" tabindex="-1"><a class="header-anchor" href="#cors概述" aria-hidden="true">#</a> CORS概述</h2><p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。</p><p>另外，规范要求，对那些<strong>可能对服务器数据产生副作用的 HTTP 请求方法</strong>（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），<strong><u>浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求</u>。</strong></p><p><strong>服务器确认允许之后，才发起实际的 HTTP 请求</strong>。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204081359603.png" alt="2ec957a3-b220-49c5-8fa1-59a82a030e89"></p><h2 id="简单请求" tabindex="-1"><a class="header-anchor" href="#简单请求" aria-hidden="true">#</a> 简单请求</h2><p>不会触发CORS预检的请求称为简单请求，满足以下<strong>所有条件</strong>的才会被视为简单请求，基本上我们日常开发只会关注前面两点</p><ol><li>使用<code>GET、POST、HEAD</code>其中一种方法</li><li>只使用了如下的<strong>安全首部字段</strong>，不得人为设置其他首部字段 <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> 仅限以下三种 <ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li><li>HTML头部header field字段：<code>DPR、Download、Save-Data、Viewport-Width、WIdth</code></li></ul></li><li>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问</li><li>请求中没有使用 ReadableStream 对象</li></ol><h2 id="预检请求" tabindex="-1"><a class="header-anchor" href="#预检请求" aria-hidden="true">#</a> 预检请求</h2><p>需预检的请求要求必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。&quot;预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响</p><p>下面的请求会触发预检请求，其实非简单请求之外的就会触发预检，就不用记那么多了</p><ol><li>使用了<code>PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH</code>方法</li><li>人为设置了非规定内的其他首部字段，参考上面简单请求的安全字段集合，还要特别注意<code>Content-Type</code>的类型</li><li><code>XMLHttpRequestUpload</code> 对象注册了任何事件监听器</li><li>请求中使用了<code>ReadableStream</code>对象</li></ol><p>以下是一个发起预检请求的例子 发起请求的<code>origin</code>与请求的服务器的<code>host</code>不同，而且根据上面的条件判断，触发了预检</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204081406993.png" alt="66210125-a3e0-422a-8def-79b1e32028c7"></p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204081412375.png" alt="a4e8f139-9ac9-4087-847c-bfe8e356695b"></p><h2 id="请求附带身份凭证-cookies" tabindex="-1"><a class="header-anchor" href="#请求附带身份凭证-cookies" aria-hidden="true">#</a> 请求附带身份凭证 -&gt; cookies</h2><p>如果发起请求时设置<code>withCredentials</code> 标志设置为 <code>true</code>，从而向服务器发送cookie， 但是如果服务器端的响应中未携带<code>Access-Control-Allow-Credentials: true</code>，浏览器将不会把响应内容返回给请求的发送者</p><p>对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin</code> 的值为<code>*</code>， 必须是某个具体的域名</p><p>注意，简单 GET 请求不会被预检；如果对此类带有身份凭证请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页</p><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204081407045.png" alt="dd16afcc-c37b-4269-a427-4e42c6e5773f"></p><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3>',23),m={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS",target:"_blank",rel:"noopener noreferrer"},_={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Server-Side_Access_Control",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.html5rocks.com/en/tutorials/cors/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy",target:"_blank",rel:"noopener noreferrer"};function b(C,S){const t=n("ExternalLinkIcon");return a(),l("div",null,[i,p,e("p",null,[o("当一个资源从与该资源本身所在的服务器不同的"),h,o("请求一个资源时，资源会发起一个跨域 HTTP 请求。同源策略参考"),e("a",u,[o("浏览器的同源策略 | MDN"),c(t)])]),g,e("p",null,[e("a",m,[o("HTTP访问控制（CORS） | MDN"),c(t)]),e("a",_,[o("Server-Side Access Control | MDN"),c(t)]),e("a",T,[o("Using CORS - HTML5 Rocks"),c(t)]),e("a",f,[o("浏览器的同源策略 | MDN"),c(t)])])])}const k=r(s,[["render",b],["__file","CORS.html.vue"]]);export{k as default};
