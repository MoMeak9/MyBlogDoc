import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as s,e}from"./app.d7b34baa.js";const t={},p=e(`<h1 id="react-实现按需加载" tabindex="-1"><a class="header-anchor" href="#react-实现按需加载" aria-hidden="true">#</a> React 实现按需加载</h1><p>如何控制好整个应用的大小，以及如何提升加载性能，才能确保应用的打开速度够快。</p><p>照此来看，为了提高首屏加载速度，我们就需要对应用进行分包。首先，在打开某个页面时，只加载这个页面相关的内容，也就是按需加载。同时，为了提升后续应用的打开速度，就需要采用高效的缓存策略，避免前端资源的重复下载。</p><h2 id="如何实现按需加载" tabindex="-1"><a class="header-anchor" href="#如何实现按需加载" aria-hidden="true">#</a> 如何实现按需加载？</h2><h3 id="使用-import-语句-定义按需加载的起始模块" tabindex="-1"><a class="header-anchor" href="#使用-import-语句-定义按需加载的起始模块" aria-hidden="true">#</a> 使用 import 语句，定义按需加载的起始模块</h3><p>所谓按需加载，就是指在某个组件需要被渲染到页面时，才会去实际地下载这个页面，以及这个页面依赖的所有代码。比如当用户打开 /users/profile 这个页面时，才会真正加载对应组件的代码。如下图所示，就展示了这样一个结构，其中 Profile Page 就是需要动态加载的组件。</p><p><img src="https://cdn.yihuiblog.top/images/4a598368ee8dcf95ed5968536105cffc.png" alt="img"></p><p>要实现这个功能，本质上在于，我们需要有动态加载模块的能力。也就是在运行时去加载模块，而不是静态地去 import 一个模块。对于这个需求，ECMA Script 标准有一个提案，专门用于动态加载模块，语法是 import(someModule)。</p><p>注意，这里的 import 和我们一般用于引入模块的静态声明方式不同，比如 import something from &#39;somemodule&#39; 。但这里的 import 是作为一个函数动态运行的，这个 import() 函数会返回一个 Promise。这样，在模块加载成功后，我们就可以在 Promise 的 then 回调函数中去使用这个模块了。</p><p><strong>虽然这只是一个提案，并没有成为标准，但是 Webpack 等打包工具利用了这样的语法去定义代码的分包。也就是说，Webpack 实现了这样的语法。</strong></p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ProfilePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义一个 state 用于存放需要加载的组件</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>RealPage<span class="token punctuation">,</span> setRealPage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 根据路径动态加载真正的组件实现</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;./RealProfilePage&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">comp</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setRealPage</span><span class="token punctuation">(</span>Comp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果组件未加载则显示 Loading 状态</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>RealPage<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">&#39;Loading....&#39;</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 组件加载成功后则将其渲染到界面</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RealPage</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，我们定义了 ProfilePage 这样一个实现按需加载功能的组件。这个组件只有被执行时，也就是渲染到界面上时，才会真正加载具体的实现代码。</p><p>这里要理解的关键点就在于，**import() 这个语句完全是由 Webpack 进行处理的。**Webpack 会将以“./RealProfilePage”模块为起点的所有依赖模块，单独打成一个包。并且，Webpack 还会生成代码，用于按需加载这个模块。</p><p>理解了这一点，我们也就知道了按需加载的实现原理：Webpack 利用了动态 import 语句，自动实现了整个应用的拆包。而我们在实际开发中，其实并不需要关心 Webpack 是如何做到的，而只需要考虑：该在哪个位置使用 import 语句去定义动态加载的拆分点。</p><p>总体需要采用的策略是：按业务模块为目标去做隔离，尽量在每个模块的起始页面去定义这个拆分点。</p><h3 id="使用-react-lodable-实现组件的异步加载" tabindex="-1"><a class="header-anchor" href="#使用-react-lodable-实现组件的异步加载" aria-hidden="true">#</a> 使用 react-lodable，实现组件的异步加载</h3><p>上面的例子你已经看到了如何去实现一个 React 组件的动态加载，它的总体思路其实主要就是三个部分：</p><ol><li>定义一个加载器组件，在使用的地方依赖于这个加载器组件而不是原组件；</li><li>在加载器组件的执行过程中，使用 import 去动态加载真实的实现代码；</li><li>处理加载过程，和加载出错的场景，确保用户体验。</li></ol>`,18),o=[p];function c(i,l){return a(),s("div",null,o)}const d=n(t,[["render",c],["__file","React 实现按需加载.html.vue"]]);export{d as default};
