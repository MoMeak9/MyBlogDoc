import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as r,e as h}from"./app.d7b34baa.js";const i={},d=h('<h1 id="牛客设计模式问题总结" tabindex="-1"><a class="header-anchor" href="#牛客设计模式问题总结" aria-hidden="true">#</a> 牛客设计模式问题总结</h1><h3 id="_1-创建型模式" tabindex="-1"><a class="header-anchor" href="#_1-创建型模式" aria-hidden="true">#</a> 1. 创建型模式</h3><p>在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p><h3 id="_2-模式分类" tabindex="-1"><a class="header-anchor" href="#_2-模式分类" aria-hidden="true">#</a> 2. 模式分类</h3><h4 id="结构型模式" tabindex="-1"><a class="header-anchor" href="#结构型模式" aria-hidden="true">#</a> 结构型模式：</h4><p>（1）代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p><p>（2）适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。(当已有类能满足目前的需求但和当前的系统兼容性比较差的情况)</p><p>（3） 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>（4）装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</p><p>（5）外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p><p>（6）享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</p><p>（7）组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p><h4 id="创建型模式" tabindex="-1"><a class="header-anchor" href="#创建型模式" aria-hidden="true">#</a> 创建型模式：</h4><p>（1）工厂方法（）</p><p>（2）原型（）</p><p>（3）抽象工厂（）</p><p>（4）生成器（）</p><p>（5）单例（）</p><h4 id="行为模式" tabindex="-1"><a class="header-anchor" href="#行为模式" aria-hidden="true">#</a> 行为模式：</h4><p>（1）责任链</p><p>（2）命令</p><p>（3）迭代器</p><p>（4）中介者</p><p>（5）备忘录</p><p>（6）观察则</p><p>（7）状态</p><p>（8）策略</p><p>（9）模板方法</p><p>（10）访问者</p><h3 id="_3-单例模式" tabindex="-1"><a class="header-anchor" href="#_3-单例模式" aria-hidden="true">#</a> 3. 单例模式</h3><ul><li>单例对于不频繁创建和销毁的对象只会增加系统开支，因为它一直存在，但是对于频繁创建和销毁的却可以在一定程度上减少开支</li><li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC</li></ul><h3 id="_4-原型模式" tabindex="-1"><a class="header-anchor" href="#_4-原型模式" aria-hidden="true">#</a> 4. 原型模式</h3><ul><li><p>原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节。</p><p>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建</p></li></ul><h3 id="_5-外观模式" tabindex="-1"><a class="header-anchor" href="#_5-外观模式" aria-hidden="true">#</a> 5. 外观模式</h3><ul><li>在外观模式中，一个子系统的外部与内部通信通过统一的外观对象进行。</li><li>在外观模式中，客户类只需要直接与外观对象进行交互。</li><li>外观模式是迪米特法则的一种具体实现。</li></ul><p>单例模式的原则： 一个类有且只有一个职责。如果这个类需要变更，那么有且至于一个让其变化的原因。</p><p>迪米特法则：最小知识原则， 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="_6-设计模式一般用来解决什么样的问题" tabindex="-1"><a class="header-anchor" href="#_6-设计模式一般用来解决什么样的问题" aria-hidden="true">#</a> 6. 设计模式一般用来解决什么样的问题？</h3><p>同一问题的不同表相。</p><blockquote><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。是用来解决重复利用的解决方案，可以对之后的问题进行简单的修改、降低成本来进行使用，设计模式要为了使设计适应变化，并且要保持流畅、简单和持续性。</p></blockquote><h3 id="_7-设计模式的两大主题" tabindex="-1"><a class="header-anchor" href="#_7-设计模式的两大主题" aria-hidden="true">#</a> 7. 设计模式的两大主题</h3><p>系统复用与系统扩展</p><h3 id="_8-策略模式" tabindex="-1"><a class="header-anchor" href="#_8-策略模式" aria-hidden="true">#</a> 8. 策略模式</h3><ul><li>Strategy角色负责决定实现策略所必须的接口</li><li>ConcreteStrategy角色负责实现Strategy角色的接口，即负责实现具体的策略（战略、方向、方法和算法）</li></ul>',44),p=[d];function t(n,l){return e(),r("div",null,p)}const _=a(i,[["render",t],["__file","牛客设计模式问题总结.html.vue"]]);export{_ as default};
