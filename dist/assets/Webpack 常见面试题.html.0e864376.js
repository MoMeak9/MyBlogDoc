import{_ as d}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as l,a as e,b as o,d as i,e as p,r}from"./app.d7b34baa.js";const s={},n=e("h1",{id:"webpack-常见面试题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#webpack-常见面试题","aria-hidden":"true"},"#"),o(" Webpack 常见面试题")],-1),t={href:"https://vue3js.cn/interview/webpack/",target:"_blank",rel:"noopener noreferrer"},h=e("p",null,"校招生整这个，真的是越来越卷了呢",-1),u=p('<h2 id="webpack中常见的loader-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#webpack中常见的loader-解决了什么问题" aria-hidden="true">#</a> Webpack中常见的Loader？解决了什么问题？</h2><ul><li>style-loader: 将css添加到DOM的内联样式标签style里</li><li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li><li>less-loader: 处理less</li><li>sass-loader: 处理sass</li><li>postcss-loader: 用postcss来处理CSS</li><li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li><li>file-loader: 分发文件到output目录并返回相对路径</li><li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li><li>html-minify-loader: 压缩HTML</li><li>babel-loader :用babel来转换ES6文件到ES</li></ul><h2 id="webpack中常见的plugin-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#webpack中常见的plugin-解决了什么问题" aria-hidden="true">#</a> Webpack中常见的Plugin？解决了什么问题？</h2><p><img src="https://cdn.yihuiblog.top/images/202209252039972.png" alt="img"></p><h2 id="loader和plugin的区别-编写loader-plugin的思路" tabindex="-1"><a class="header-anchor" href="#loader和plugin的区别-编写loader-plugin的思路" aria-hidden="true">#</a> Loader和Plugin的区别？编写Loader，Plugin的思路？</h2><p>前面两节我们有提到<code>Loader</code>与<code>Plugin</code>对应的概念，先来回顾下</p><ul><li>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</li><li>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事</li></ul><h2 id="webpack的热更新是如何做到的-原理是什么" tabindex="-1"><a class="header-anchor" href="#webpack的热更新是如何做到的-原理是什么" aria-hidden="true">#</a> Webpack的热更新是如何做到的？原理是什么？</h2><p><code>HMR</code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p><p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p><p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p><h2 id="webpack-proxy工作原理-为什么能解决跨域" tabindex="-1"><a class="header-anchor" href="#webpack-proxy工作原理-为什么能解决跨域" aria-hidden="true">#</a> Webpack proxy工作原理？为什么能解决跨域?</h2><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p><p>基本行为就是接收客户端发送的请求后转发给其他服务器</p><p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p><p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p><h2 id="如何借助webpack来优化前端性能" tabindex="-1"><a class="header-anchor" href="#如何借助webpack来优化前端性能" aria-hidden="true">#</a> 如何借助Webpack来优化前端性能？</h2><ul><li>JS代码压缩</li><li>CSS代码压缩</li><li>HTML文件代码压缩</li><li>文件大小压缩</li><li>图片压缩</li><li>Tree Shaking</li><li>代码分离</li><li>内联 chunk</li></ul><h2 id="如何提高webpack的构建速度" tabindex="-1"><a class="header-anchor" href="#如何提高webpack的构建速度" aria-hidden="true">#</a> 如何提高Webpack的构建速度？</h2><ul><li><p>优化 loader 配置</p><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p></li><li><p>合理使用 resolve.extensions</p><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到项目的模块代码</p></li><li><p>优化 resolve.modules</p><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件 当安装的第三方模块都放在项目根目录下的 <code>./node_modules</code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找</p></li><li><p>优化 resolve.alias</p><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p></li><li><p>使用 DLLPlugin 插件</p><p><code>DLL</code>全称是 动态链接库，是为软件在winodw中实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p></li><li><p>使用 cache-loader</p><p>在一些性能开销较大的 <code>loader</code>之前添加 <code>cache-loader</code>，以将结果缓存到<strong>磁盘</strong>里，显著提升二次构建速度。保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code>loader</code></p></li><li><p>terser 启动多线程</p><p>使用多进程并行运行来提高构建速度，毕竟JS是单线程的</p></li><li><p>合理使用 sourceMap</p><p>打包生成 <code>sourceMap</code> 的时候，<strong>如果信息越详细，打包速度就会越慢</strong>。</p></li></ul><h2 id="与webpack类似的工具还有哪些-区别" tabindex="-1"><a class="header-anchor" href="#与webpack类似的工具还有哪些-区别" aria-hidden="true">#</a> 与Webpack类似的工具还有哪些？区别？</h2><p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code>。</p><h3 id="rollup" tabindex="-1"><a class="header-anchor" href="#rollup" aria-hidden="true">#</a> Rollup</h3><p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p><p><strong>特点：</strong></p><ul><li>代码效率更简洁、效率更高</li><li>默认支持 Tree-shaking</li></ul><p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup</code>需要使用插件去完成</p><p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p><p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p><h3 id="parcel" tabindex="-1"><a class="header-anchor" href="#parcel" aria-hidden="true">#</a> Parcel</h3><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p><p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。</p><h3 id="snowpack" tabindex="-1"><a class="header-anchor" href="#snowpack" aria-hidden="true">#</a> Snowpack</h3><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p><p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p><h3 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> Vite ⭐</h3><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p><p>它主要由两部分组成：</p><ul><li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li><li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li></ul><p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p><ul><li>快速的冷启动</li><li>即时的模块热更新</li><li>真正的按需编译</li></ul><p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p><p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p><img src="https://cdn.yihuiblog.top/images/202209252009034.png" alt="img" style="zoom:50%;"><p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>',45);function b(k,w){const c=r("ExternalLinkIcon");return a(),l("div",null,[n,e("blockquote",null,[e("p",null,[e("a",t,[o("web前端面试 - 面试官系列"),i(c)])]),h]),u])}const m=d(s,[["render",b],["__file","Webpack 常见面试题.html.vue"]]);export{m as default};
