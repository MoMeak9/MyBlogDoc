import{_ as c}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as r,a as n,b as e,d as a,e as o,r as i}from"./app.d7b34baa.js";const l={},p=o('<h1 id="render-阶段流程" tabindex="-1"><a class="header-anchor" href="#render-阶段流程" aria-hidden="true">#</a> render 阶段流程</h1><h2 id="总览" tabindex="-1"><a class="header-anchor" href="#总览" aria-hidden="true">#</a> 总览</h2><ul><li>同异步更新调用不同的方法，<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>，他们唯一的区别是是否调用<code>shouldYield</code></li><li><code>shouldYield</code>终止循环、取决于浏览器帧<a href="">剩余时间</a></li><li>Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为递(beginWork)、归(completeWork)</li></ul><h2 id="递归遍历树" tabindex="-1"><a class="header-anchor" href="#递归遍历树" aria-hidden="true">#</a> 递归遍历树</h2><h3 id="递-阶段" tabindex="-1"><a class="header-anchor" href="#递-阶段" aria-hidden="true">#</a> “递”阶段</h3>',5),d=n("code",null,"rootFiber",-1),u=n("code",null,"Fiber节点",-1),k={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058",target:"_blank",rel:"noopener noreferrer"},b=n("p",null,[e("该方法会根据传入的"),n("code",null,"Fiber节点"),e("创建"),n("code",null,"子Fiber节点"),e("，并将这两个"),n("code",null,"Fiber节点"),e("连接起来。")],-1),m=n("p",null,"当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。",-1),h=n("h3",{id:"归-阶段",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#归-阶段","aria-hidden":"true"},"#"),e(" “归”阶段")],-1),v={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652",target:"_blank",rel:"noopener noreferrer"},g=n("code",null,"Fiber节点",-1),_=o(`<p>当某个<code>Fiber节点</code>执行完<code>completeWork</code>，如果其存在<code>兄弟Fiber节点</code>（即<code>fiber.sibling !== null</code>），会进入其<code>兄弟Fiber</code>的“递”阶段。</p><blockquote><p>注意多子树结构、存储的是第一个子节点和第一个（右）兄弟节点</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 指向父级Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向子Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向右边第一个兄弟Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>如果不存在<code>兄弟Fiber</code>，会进入<code>父级Fiber</code>的“归”阶段。</p><p>“递”和“归”阶段会交错执行直到“归”到<code>rootFiber</code>。至此，<code>render阶段</code>的工作就结束了。</p><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h3><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      i am
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">KaSong</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>render 依次执行</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1.</span> rootFiber beginWork
<span class="token number">2.</span> App Fiber beginWork
<span class="token number">3.</span> div Fiber beginWork
<span class="token number">4.</span> <span class="token string">&quot;i am&quot;</span> Fiber beginWork
<span class="token number">5.</span> <span class="token string">&quot;i am&quot;</span> Fiber completeWork
<span class="token number">6.</span> span Fiber beginWork
<span class="token number">7.</span> span Fiber completeWork
<span class="token number">8.</span> div Fiber completeWork
<span class="token number">9.</span> App Fiber completeWork
<span class="token number">10.</span> rootFiber completeWork
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>之所以没有 “KaSong” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的<code>Fiber</code>，<code>React</code>会特殊处理。</p></blockquote><h2 id="beginwork" tabindex="-1"><a class="header-anchor" href="#beginwork" aria-hidden="true">#</a> beginWork()</h2><p><code>beginWork</code>的工作是传入<code>当前Fiber节点</code>，创建<code>子Fiber节点</code>，我们从传参来看看具体是如何做的。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">renderLanes</span><span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...省略函数体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中传参：</p><ul><li>current：当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>workInProgress.alternate</code></li><li>workInProgress：当前组件对应的<code>Fiber节点</code></li><li>renderLanes：优先级相关，在讲解<code>Scheduler</code>时再讲解</li></ul>`,14),f={href:"https://react.iamkasong.com/process/doubleBuffer.html#mount%E6%97%B6",target:"_blank",rel:"noopener noreferrer"},F=n("code",null,"rootFiber",-1),W=n("code",null,"mount",-1),x=n("code",null,"Fiber节点",-1),w=n("code",null,"Fiber节点",-1),y=n("code",null,"mount",-1),j=n("code",null,"current === null",-1),R=o(`<p>组件<code>update</code>时，由于之前已经<code>mount</code>过，所以<code>current !== null</code>。</p><p>所以我们可以通过<code>current === null ?</code>来区分组件是处于<code>mount</code>还是<code>update</code>。</p><h3 id="根据current-区分执行阶段" tabindex="-1"><a class="header-anchor" href="#根据current-区分执行阶段" aria-hidden="true">#</a> 根据current 区分执行阶段</h3><ul><li><code>update</code>时：如果<code>current</code>存在，在满足一定条件时可以复用<code>current</code>节点，这样就能克隆<code>current.child</code>作为<code>workInProgress.child</code>，而不需要新建<code>workInProgress.child</code>。</li><li><code>mount</code>时：除<code>fiberRootNode</code>以外，<code>current === null</code>。会根据<code>fiber.tag</code>不同，创建不同类型的<code>子Fiber节点</code></li></ul><h2 id="completework" tabindex="-1"><a class="header-anchor" href="#completework" aria-hidden="true">#</a> completeWork()</h2><p>类似<code>beginWork</code>，<code>completeWork</code>也是针对不同<code>fiber.tag</code>调用不同的处理逻辑。</p><h2 id="流程结尾" tabindex="-1"><a class="header-anchor" href="#流程结尾" aria-hidden="true">#</a> 流程结尾</h2><p>至此，<code>render阶段</code>全部工作完成。在<code>performSyncWorkOnRoot</code>函数中<code>fiberRootNode</code>被传递给<code>commitRoot</code>方法，开启<code>commit阶段</code>工作流程。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,9);function q(I,B){const s=i("ExternalLinkIcon");return t(),r("div",null,[p,n("p",null,[e("首先从"),d,e("开始向下深度优先遍历。为遍历到的每个"),u,e("调用"),n("a",k,[e("beginWork方法"),a(s)]),e("。")]),b,m,h,n("p",null,[e("在“归”阶段会调用"),n("a",v,[e("completeWork"),a(s)]),e("处理"),g,e("。")]),_,n("p",null,[e("除"),n("a",f,[F,a(s)]),e("以外， 组件"),W,e("时，由于是首次渲染，是不存在当前组件对应的"),x,e("在上一次更新时的"),w,e("，即"),y,e("时"),j,e("。")]),R])}const N=c(l,[["render",q],["__file","render 阶段流程.html.vue"]]);export{N as default};
