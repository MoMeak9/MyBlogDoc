import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as l,e as o}from"./app.d7b34baa.js";const t={},a=o('<h1 id="node-笔记-9-深入事件循环" tabindex="-1"><a class="header-anchor" href="#node-笔记-9-深入事件循环" aria-hidden="true">#</a> Node 笔记（9）深入事件循环</h1><h2 id="阻塞io和非阻塞io" tabindex="-1"><a class="header-anchor" href="#阻塞io和非阻塞io" aria-hidden="true">#</a> 阻塞IO和非阻塞IO</h2><p>操作系统为我们提供了阻塞式调用和非阻塞式调用：</p><ul><li><strong>阻塞式调用：</strong> 调用结果返回之前，当前线程处于阻塞态（阻塞态CPU是不会分配时间片的），调用线程只有 在得到调用结果之后才会继续执行。</li><li><strong>非阻塞式调用：</strong> 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。</li></ul><p>所以我们开发中的很多耗时操作，都可以基于这样的 非阻塞式调用：</p><ul><li>比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的工作；</li><li>比如文件读写的IO操作，我们可以使用操作系统提供的基于事件的回调机制；</li></ul><h2 id="非阻塞io的问题" tabindex="-1"><a class="header-anchor" href="#非阻塞io的问题" aria-hidden="true">#</a> 非阻塞IO的问题</h2><p>但是非阻塞IO也会存在一定的问题：我们并没有获取到需要读取（我们以读取为例）的结果，那么就意味着为了可以知道是否读取到了完整的数据，我们需要频繁的去确定读取到的数据是否是完整的；<strong>这个过程我们称之为轮询操作；</strong></p><p><strong>那么这个轮询的工作由谁来完成呢？</strong></p><p>libuv提供了一个线程池（Thread Pool）：</p><ul><li>线程池会负责所有相关的操作，并且会通过轮训等方式等待结果；</li><li>当获取到结果时，就可以将对应的回调放到事件循环（某一个事件队列）中；</li><li>事件循环就可以负责接管后续的回调工作，告知JavaScript应用程序执行对应的回调函数；</li></ul><h2 id="阻塞和非阻塞-同步和异步的区别" tabindex="-1"><a class="header-anchor" href="#阻塞和非阻塞-同步和异步的区别" aria-hidden="true">#</a> 阻塞和非阻塞，同步和异步的区别</h2><p><strong>阻塞和非阻塞是对于被调用者来说的</strong>，在我们这里就是系统调用，操作系统为我们提供了阻塞调用和非阻塞调用。</p><p>**同步和异步是对于调用者来说的，**如果我们在发起调用之后，不会进行其他任何的操作，只是等待结果，这个过程就称之为同步调用；如果我们再发起调用之后，并不会等待结果，继续完成其他的工作，等到有回调时再去执行，这个过程就是 异步调用</p><p>Libuv采用的就是非阻塞异步IO的调用方式</p><h2 id="node事件循环的阶段" tabindex="-1"><a class="header-anchor" href="#node事件循环的阶段" aria-hidden="true">#</a> Node事件循环的阶段</h2><p>一次完整的事件循环Tick分成很多个阶段：</p><ul><li><strong>定时器（Timers）</strong>：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</li><li><strong>待定回调（Pending Callback）</strong>：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED。</li><li>**idle, prepare：**仅系统内部使用。</li><li>**轮询（Poll）：**检索新的 I/O 事件；执行与 I/O 相关的回调；</li><li>**检测：**setImmediate() 回调函数在这里执行。</li><li>**关闭的回调函数：**一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)。</li></ul><p><img src="https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/202204101450106.png" alt="image-20220410145058029"></p><h3 id="node的微任务和宏任务" tabindex="-1"><a class="header-anchor" href="#node的微任务和宏任务" aria-hidden="true">#</a> Node的微任务和宏任务</h3><p>我们会发现从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：</p><ul><li>宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；</li><li>微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；</li></ul><p><strong>Node中的事件循环不只是 微任务队列和 宏任务队列：</strong></p><p>微任务队列：</p><ul><li>next tick queue：process.nextTick；</li><li>other queue：Promise的then回调、queueMicrotask；</li></ul><p>宏任务队列：</p><ul><li>timer queue：setTimeout、setInterval；</li><li>poll queue：IO事件；</li><li>check queue：setImmediate；</li><li>close queue：close事件；</li></ul>',27),r=[a];function s(n,c){return i(),l("div",null,r)}const h=e(t,[["render",s],["__file","Node 笔记（9）深入事件循环.html.vue"]]);export{h as default};
