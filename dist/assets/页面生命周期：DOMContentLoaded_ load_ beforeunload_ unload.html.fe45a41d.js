import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as t,a as n,d as c,e as a,r as p}from"./app.d7b34baa.js";const d={},i=a(`<h1 id="页面生命周期-domcontentloaded-load-beforeunload-unload" tabindex="-1"><a class="header-anchor" href="#页面生命周期-domcontentloaded-load-beforeunload-unload" aria-hidden="true">#</a> 页面生命周期：DOMContentLoaded, load, beforeunload, unload</h1><p>HTML页面的生命周期有以下三个重要事件：</p><ul><li><code>DOMContentLoaded</code> —— 浏览器已经完全加载了 HTML，DOM 树已经构建完毕，但是像是 <code>&lt;img&gt;</code> 和样式表等外部资源可能并没有下载完毕。</li><li><code>load</code> —— 浏览器已经加载了所有的资源（图像，样式表等）。</li><li><code>beforeunload/unload</code> —— 当用户离开页面的时候触发。</li></ul><p>每个事件都有特定的用途</p><ul><li><code>DOMContentLoaded</code> —— <strong>DOM 加载</strong>完毕，所以 JS 可以访问所有 DOM 节点，初始化界面。</li><li><code>load</code> —— <strong>附加资源</strong>已经加载完毕，可以在此事件触发时获得图像的大小（如果没有被在 HTML/CSS 中指定）</li><li><code>beforeunload/unload</code> —— 用户正在离开页面：可以询问用户是否保存了更改以及是否确定要离开页面。</li></ul><h2 id="domcontentloaded" tabindex="-1"><a class="header-anchor" href="#domcontentloaded" aria-hidden="true">#</a> DOMContentLoaded</h2><p><code>DOMContentLoaded</code> 由 <code>document</code> 对象触发。</p><p>我们使用 <code>addEventListener</code> 来监听它：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;DOMContentLoaded&quot;</span><span class="token punctuation">,</span> ready<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举个例子</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">function</span> <span class="token function">ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;DOM is ready&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// image is not yet loaded (unless was cached), so the size is 0x0</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Image size: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>img<span class="token punctuation">.</span>offsetWidth<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">x</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>img<span class="token punctuation">.</span>offsetHeight<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;DOMContentLoaded&quot;</span><span class="token punctuation">,</span> ready<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>img id<span class="token operator">=</span><span class="token string">&quot;img&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中 <code>DOMContentLoaded</code> 在 document 加载完成后就被触发，无需等待其他资源的载入，所以 <code>alert</code> 输出的图像的大小为 0。</p><p>这么看来 <code>DOMContentLoaded</code> 似乎很简单，DOM 树构建完毕之后就运行该事件，不过其实存在一些陷阱。</p><h3 id="domcontentloaded-和-js-脚本" tabindex="-1"><a class="header-anchor" href="#domcontentloaded-和-js-脚本" aria-hidden="true">#</a> DOMContentLoaded 和 JS 脚本</h3><p>当浏览器在解析 HTML 页面时遇到了 <code>&lt;script&gt;...&lt;/script&gt;</code> 标签，将无法继续构建DOM树（译注：UI 渲染线程与 JS 引擎是互斥的，当 JS 引擎执行时 UI 线程会被挂起），必须立即执行脚本。所以 <code>DOMContentLoaded</code> 有可能在所有脚本执行完毕后触发。</p><p>外部脚本（带 <code>src</code> 的）的加载和解析也会暂停DOM树构建，所以 <code>DOMContentLoaded</code> 也会等待外部脚本。</p><p>不过有两个例外是带 <code>async</code> 和 <code>defer</code> 的外部脚本，他们告诉浏览器继续解析而不需要等待脚本的执行，所以用户可以在脚本加载完成前可以看到页面，有较好的用户体验。</p><p><code>async</code> 和 <code>defer</code> 属性仅仅对外部脚本起作用，并且他们在 <code>src</code> 不存在时会被自动忽略。</p><p>它们都告诉浏览器继续处理页面上的内容，而在后台加载脚本，然后在脚本加载完毕后再执行。所以脚本不会阻塞DOM树的构建和页面的渲染。</p><p><strong>区别：</strong></p><table><thead><tr><th></th><th>顺序</th><th><code>DOMContentLoaded</code></th></tr></thead><tbody><tr><td><code>async</code></td><td><strong>加载优先顺序</strong>。脚本在文档中的顺序不重要 —— 先加载完成的先执行</td><td>不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自于缓存，同时文档足够长，就会发生这种情况。</td></tr><tr><td><code>defer</code></td><td><strong>文档顺序</strong>（它们在文档中的顺序）</td><td>在文档加载和解析完成之后（如果需要，则会等待），即在 <code>DOMContentLoaded</code> 之前执行。</td></tr></tbody></table><blockquote><p>表格参照：https://zh.javascript.info/script-async-defer</p></blockquote><h3 id="domcontentloaded-与样式表" tabindex="-1"><a class="header-anchor" href="#domcontentloaded-与样式表" aria-hidden="true">#</a> DOMContentLoaded 与样式表</h3><p>外部样式表并不会阻塞 DOM 的解析，所以 <code>DOMContentLoaded</code> 并不会被它们影响。</p><p>不过仍然有一个陷阱：如果在样式后面有一个内联脚本，那么脚本必须等待样式先加载完。简单来说，JS 因为有可能会去获取 DOM 的样式，所以 JS 会等待样式表加载完毕，而 JS 是阻塞 DOM 的解析的，所以在有外部样式表的时候，JS 会一直阻塞到外部样式表下载完毕，所以，这直接影响DOMContentLoaded的完成。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>link type<span class="token operator">=</span><span class="token string">&quot;text/css&quot;</span> rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;style.css&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token comment">// 脚本直到样式表加载完毕后才会执行。</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">.</span>marginTop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发生这种事的原因是脚本也许会像上面的例子中所示，去得到一些元素的坐标或者基于样式的属性。所以他们自然要等到样式加载完毕才可以执行。</p><p><code>DOMContentLoaded </code>需要等待脚本的执行，脚本又需要等待样式的加载。</p><h3 id="浏览器的自动补全" tabindex="-1"><a class="header-anchor" href="#浏览器的自动补全" aria-hidden="true">#</a> 浏览器的自动补全</h3><p>Firefox, Chrome 和 Opera 会在 <code>DOMContentLoaded</code> 执行时自动补全表单。</p><p>例如，如果页面有登录的界面，浏览器记住了该页面的用户名和密码，那么在 <code>DOMContentLoaded</code> 运行的时候浏览器会试图自动补全表单（如果用户设置允许）。</p><p>所以如果 <code>DOMContentLoaded</code> 被一个需要长时间执行的脚本阻塞，那么自动补全也会等待。你也许见过某些网站（如果你的浏览器开启了自动补全）—— 浏览器并不会立刻补全登录项，而是等到整个页面加载完毕后才填充。这就是因为在等待 <code>DOMContentLoaded</code> 事件。</p><blockquote><p>defer脚本一定是在DOMContentLoaded事件前执行。</p></blockquote><p><code>defer</code> 是会阻塞 <code>DOMContentLoaded</code> 的，被 <code>defer</code> 的脚本要在 <code>DOMContentLoaded</code> 触发前执行，所以如果HTML很快就加载完了（先不考虑 CSS 阻塞 <code>DOMContentLoaded</code> 的情况），而 <code>defer</code> 的脚本还没有加载完，浏览器就会等，等到脚本加载完，执行完，再触发 <code>DOMContentLoaded</code>，放上一张图（取自在 devTool 下分析自己写的一个页面）</p>`,34),l={href:"https://user-images.githubusercontent.com/12322740/35795637-bb7d438c-0a94-11e8-9fd6-71bfe1b99b32.png",target:"_blank",rel:"noopener noreferrer"},r=n("img",{src:"https://cdn.yihuiblog.top/images/202210302046112.png",alt:"image"},null,-1),u=a(`<p>可以看到，HTML很快就加载和解析完毕（CSS 在这里是动态加载的，不阻塞 <code>DOMContentLoaded</code>），jQuery 和main.js 的脚本是 <code>defer</code> 的， <code>DOMContentLoaded</code>（蓝线）一直在等，等到这两个脚本下载完并执行完，才触发了 <code>DOMContentLoaded</code>。 从这个角度看来，<code>defer</code> 和把脚本放在 <code>&lt;/body&gt;</code> 前真是没啥区别，只不过 <code>defer</code> 脚本位 于<code>head </code>中，更早被读到，加载更早，而且不担心会被其他的脚本推迟下载开始的时间。</p><h2 id="window-onload" tabindex="-1"><a class="header-anchor" href="#window-onload" aria-hidden="true">#</a> window.onload</h2><p><code>window</code> 对象上的 <code>onload</code> 事件在所有文件包括样式表，图片和其他资源下载完毕后触发。</p><p>下面的例子正确检测了图片的大小，因为 <code>window.onload</code> 会等待所有图片的加载。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;Page loaded&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// image is loaded at this time</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Image size: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>img<span class="token punctuation">.</span>offsetWidth<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">x</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>img<span class="token punctuation">.</span>offsetHeight<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>img id<span class="token operator">=</span><span class="token string">&quot;img&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="window-onunload" tabindex="-1"><a class="header-anchor" href="#window-onunload" aria-hidden="true">#</a> window.onunload</h2><p>用户离开（关闭）页面的时候，<code>window</code> 对象上的 <code>unload</code> 事件会被触发，我们可以做一些不存在延迟的事情，比如关闭弹出的窗口，可是我们无法阻止用户转移到另一个页面上。</p><p>所以我们需要使用另一个事件 — <code>onbeforeunload</code>。</p><h2 id="window-onbeforeunload" tabindex="-1"><a class="header-anchor" href="#window-onbeforeunload" aria-hidden="true">#</a> window.onbeforeunload</h2><p>如果用户即将离开页面或者关闭窗口时，<code>beforeunload</code> 事件将会被触发以进行额外的确认。</p><p>浏览器将显示返回的字符串，举个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onbeforeunload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;There are unsaved changes. Leave now?&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有些浏览器像 <strong>Chrome 和火狐</strong>会忽略返回的字符串取而代之显示浏览器自身的文本，这是为了安全考虑，来保证用户不受到错误信息的误导。</p><h2 id="readystate" tabindex="-1"><a class="header-anchor" href="#readystate" aria-hidden="true">#</a> readyState</h2><p>如果我们在整个页面加载完毕后设置 <code>DOMContentLoaded</code> 会发生什么呢？</p><p>啥也没有，<code>DOMContentLoaded</code> 不会被触发。</p><p><strong><code>document.readyState </code>属性给了我们加载的信息</strong>，有三个可能的值：</p><ul><li><code>loading</code> 加载 —— document仍在加载。</li><li><code>interactive</code> 互动 —— 文档已经完成加载，文档已被解析，但是诸如图像，样式表和框架之类的子资源仍在加载。</li><li><code>complete</code> —— 文档和所有子资源已完成加载。状态表示 <code>load</code> 事件即将被触发。</li></ul><p>所以我们可以检查 <code>document.readyState</code> 的状态，如果没有就绪可以选择挂载事件，如果已经就绪了就可以直接立即执行。</p><p>像这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function work() { /*...*/ }

if (document.readyState == &#39;loading&#39;) {
  document.addEventListener(&#39;DOMContentLoaded&#39;, work);
} else {
  work();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每当文档的加载状态改变的时候就有一个 <code>readystatechange</code> 事件被触发，所以我们可以打印所有的状态。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// current state</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// print state changes</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;readystatechange&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>readystatechange</code> 是追踪页面加载的一个可选的方法，很早之前就已经出现了。不过现在很少被使用了，为了保持完整性还是介绍一下它。</p><p><code>readystatechange</code> 的在各个事件中的执行顺序又是如何呢？</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* output the time and message */</span> <span class="token punctuation">}</span>
  <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;initial readyState:&#39;</span> <span class="token operator">+</span> document<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">;</span>

  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;readystatechange&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;readyState:&#39;</span> <span class="token operator">+</span> document<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;DOMContentLoaded&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;DOMContentLoaded&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;window onload&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">&quot;iframe.html&quot;</span> onload<span class="token operator">=</span><span class="token string">&quot;log(&#39;iframe onload&#39;)&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">&quot;http://en.js.cx/clipart/train.gif&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;img&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;img onload&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p><ol><li><code>[1] initial readyState:loading</code></li><li><code>[2] readyState:interactive</code></li><li><code>[2] DOMContentLoaded</code></li><li><code>[3] iframe onload</code></li><li><code>[4] readyState:complete</code></li><li><code>[4] img onload</code></li><li><code>[4] window onload</code></li></ol><p>方括号中的数字表示他们发生的时间，真实的发生时间会更晚一点，不过相同数字的时间可以认为是在同一时刻被按顺序触发（误差在几毫秒之内）</p><ul><li><code>document.readyState</code> 在 <code>DOMContentLoaded</code> 前一刻变为 <code>interactive</code>，这两个事件可以认为是同时发生。</li><li><code>document.readyState</code> 在所有资源加载完毕后（包括 <code>iframe</code> 和 <code>img</code>）变成 <code>complete</code>，我们可以看到<code>complete</code>、 <code>img.onload</code> 和 <code>window.onload</code> 几乎同时发生，区别就是 <code>window.onload</code> 在所有其他的 <code>load</code> 事件之后执行。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><p>当 DOM 准备就绪时，<code>document</code> 上的 <code>DOMContentLoaded</code> 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。</p><ul><li>诸如 <code>&lt;script&gt;...&lt;/script&gt;</code> 或 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 之类的脚本会阻塞 <code>DOMContentLoaded</code>，浏览器将等待它们执行结束，<code>async</code> 不在此列，但<code>defer</code>在此之前执行。</li><li>图片和其他资源仍然可以继续被加载。</li></ul></li><li><p><code>load</code> 事件在页面所有资源被加载完毕后触发，通常我们不会用到这个事件，因为我们不需要等那么久。</p></li><li><p><code>beforeunload</code> 在用户即将离开页面时触发，它返回一个字符串，浏览器会向用户展示并询问这个字符串以确定是否离开。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。</p></li><li><p><code>unload</code> 在用户已经离开时触发，我们在这个阶段仅可以做一些没有延迟的操作，由于种种限制，很少被使用。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 <code>navigator.sendBeacon</code> 来发送网络请求。</p></li><li><p><code>document.readyState</code>是文档的当前状态，可以在<code>readystatechange</code> 事件中跟踪状态更改：</p><ul><li><code>loading</code> —— 文档正在被加载。</li><li><code>interactive</code> —— 文档已被解析完成，与 <code>DOMContentLoaded</code> 几乎同时发生，但是在 <code>DOMContentLoaded</code> 之前发生。</li><li><code>complete</code> —— 文档和资源均已加载完成，与 <code>window.onload</code> 几乎同时发生，但是在 <code>window.onload</code> 之前发生。</li></ul></li></ul><blockquote><p><strong>参考：</strong></p><p>http://javascript.info/onload-ondomcontentloaded</p><p>https://github.com/fi3ework/blog/issues/3</p></blockquote>`,33);function k(m,v){const s=p("ExternalLinkIcon");return o(),t("div",null,[i,n("p",null,[n("a",l,[r,c(s)])]),u])}const h=e(d,[["render",k],["__file","页面生命周期：DOMContentLoaded, load, beforeunload, unload.html.vue"]]);export{h as default};
