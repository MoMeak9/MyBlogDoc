import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as a,a as e,b as t,d as n,e as r,r as o}from"./app.d7b34baa.js";const d={},c=e("h1",{id:"事件循环是如何影响页面渲染的",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#事件循环是如何影响页面渲染的","aria-hidden":"true"},"#"),t(" 事件循环是如何影响页面渲染的？")],-1),u={href:"https://harttle.land/2019/01/16/how-eventloop-affects-rendering.html#header-3",target:"_blank",rel:"noopener noreferrer"},m={href:"https://harttle.land/2019/01/16/how-eventloop-affects-rendering.html#header-4",target:"_blank",rel:"noopener noreferrer"},h=e("code",null,"setTimeout",-1),p=e("code",null,"setInterval",-1),_=e("code",null,"setImmediate",-1),g=e("code",null,"Promise.prototype.then",-1),v=e("code",null,"postMessage",-1),b=e("code",null,"requestAnimationFrame",-1),k={href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model",target:"_blank",rel:"noopener noreferrer"},f=e("h2",{id:"tl-dr",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#tl-dr","aria-hidden":"true"},"#"),t(" TL;DR")],-1),x=e("ul",null,[e("li",null,"页面渲染/交互任务也会插入在 Task Queue 中，会与各种异步机制插入的任务交错执行。"),e("li",null,"Microtask Queue 会在下一个任务开始之前清空。"),e("li",null,"单个耗时任务和 Microtask Queue 都会阻塞页面交互，Task Queue 则不影响。"),e("li",null,"渲染时机可以通过 requestAnimationFrame 精确控制。"),e("li",null,"setImmediate 与 setTimeout 一样使用 Task Queue，但克服了 4ms 限制。")],-1),T=e("h2",{id:"任务与队列的概念",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#任务与队列的概念","aria-hidden":"true"},"#"),t(" 任务与队列的概念")],-1),y={href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model",target:"_blank",rel:"noopener noreferrer"},I=e("li",null,[e("strong",null,"任务与调用栈"),t('。由于单线程的特性，每个 JavaScript 执行上下文只有一个调用栈，其中保存着当前任务中所有未执行完的函数。只要调用栈非空，JavaScript 引擎就会持续地、不被打断地（从进程内的角度来看）执行完当前栈中的所有函数，因此 JavaScript 有 "run-to-completion" 的特性。调用栈被清空时意味着当前任务执行结束。')],-1),w=e("li",null,[e("strong",null,"Task Queue"),t(" 是事件循环的主要数据结构。当前调用栈为空时（上一个任务已经完成），事件循环机制会持续地轮询 Task Queue，只要队列中有任务就拿出来执行。在任务执行期间插入的任务会进入 Task Queue 尾部。会加入 Task 队列的包括：setTimeout, setInterval, setImmediate，postMessage，MessageChannel，UI 事件，I/O，页面渲染。")],-1),P=e("strong",null,"Microtask Queue",-1),M={href:"https://harttle.land/2016/08/10/promise.html",target:"_blank",rel:"noopener noreferrer"},Q=r(`<blockquote><p>上述异步 API 的分类依据的是最新标准或最新实现。存在一些例外，比如：Node &lt; 9 的 process.nextTick 实现的是 Task 语义（而非 Microtask）；IE8 中的 postMessage 是同步的；Edge 浏览器在点击事件处理函数之间不会清空 Microtask Queue。</p></blockquote><p>无论是 Task Queue 还是 Microtask Queue，其中的 task 和 microtask 的执行都是异步的。 为了对上述两个队列有更直观的认识，这里举个例子：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>setTimeout(() =&gt; console.log(&#39;setTimeout&#39;));
Promise.resolve().then(() =&gt; {
    console.log(&#39;Promise&#39;);
    Promise.resolve().then(() =&gt; console.log(&#39;Promise queued by Promise&#39;));
});
console.log(&#39;stack&#39;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码片段中有两个Task（stack, setTimeout），两个 Microtask（Promise、Promise queued by Promise）。 stack 是当前任务会先执行；setTimeout 是第二个任务，在它执行前会清空 Microtask Queue。 这时 Microtask Queue 只有一个 Microtask（Promise）， 在它执行的过程中会插入第二个 Microtask（Promise queued by Promise）。 这些 Microtask 都会在下一个 Task（setTimeout）之前执行。因此输出为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>stack
Promise
Promise queued by Promise
setTimeout
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),q=e("code",null,".then",-1),A=e("code",null,"new Promise",-1),S={href:"https://harttle.land/2017/06/26/promise-callback-execution.html",target:"_blank",rel:"noopener noreferrer"},E={href:"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/",target:"_blank",rel:"noopener noreferrer"},z=e("h2",{id:"何时会阻塞-ui",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#何时会阻塞-ui","aria-hidden":"true"},"#"),t(" 何时会阻塞 UI")],-1),J={href:"https://harttle.land/2017/08/15/browser-render-frame.html",target:"_blank",rel:"noopener noreferrer"},N=r('<p>在 “Loop for 10 seconds” 部分我们写了 4 种不同的循环，它们的表现如下：</p><table><thead><tr><th style="text-align:center;">循环 API</th><th style="text-align:center;">队列类型</th><th style="text-align:center;">期间页面能否交互?</th><th style="text-align:center;">每秒执行次数</th></tr></thead><tbody><tr><td style="text-align:center;">while(true)</td><td style="text-align:center;">当前任务</td><td style="text-align:center;">否</td><td style="text-align:center;">701665.8</td></tr><tr><td style="text-align:center;">Promise</td><td style="text-align:center;">Microtask Queue</td><td style="text-align:center;">否</td><td style="text-align:center;">609555.4</td></tr><tr><td style="text-align:center;">setTimeout</td><td style="text-align:center;">Task Queue</td><td style="text-align:center;">是</td><td style="text-align:center;">208.3</td></tr><tr><td style="text-align:center;">requestAnimationFrame</td><td style="text-align:center;">Task Queue</td><td style="text-align:center;">是</td><td style="text-align:center;">59</td></tr></tbody></table>',2),C=e("li",null,"页面不可交互是指：无法点击其他按钮、无法操作输入控件、无法选择/赋值页面文本。",-1),F={href:"https://harttle.land/2018/06/23/uiwebview-bugs.html",target:"_blank",rel:"noopener noreferrer"},L=r(`<p>单个的耗时任务和 Microtask Queue 都会阻塞页面交互，Task 则不影响。 因为 Task 之间浏览器有机会会插入 UI 任务。 这里还可以观察到 <code>setTimeout</code> 虽然设置了 0 延时但调用次数远小于 while，甚至远小于 Microtask。 下文 setImmediate 章节会详细讨论原因。</p><h2 id="渲染任务的时机" tabindex="-1"><a class="header-anchor" href="#渲染任务的时机" aria-hidden="true">#</a> 渲染任务的时机</h2><p>有时我们希望精确地控制浏览器在每一帧的绘制，这时就要了解浏览器绘制的时机。 首先举个例子，我们希望页面背景闪现一下红色：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>document.body.style.background = &#39;red&#39;;
document.body.style.background = &#39;white&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码一定达不到效果，背景会稳定地呈现白色。 因为 JavaScript “run-to-completion” 的特性，在上述两行代码之间不可能插入渲染任务。 这时可能有人想到 setTimeout：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>document.body.style.background = &#39;red&#39;;
setTimeout(function () {
    document.body.style.background = &#39;white&#39;;
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样两次背景设置会在不同的任务中执行，如果这两个任务之间插入了渲染任务背景就会发生闪动。 但渲染任务是 16ms 一次，你怎么知道浏览器会正好插入在这两个任务之间？ 因此上述代码只会几率性起作用，背景闪动的几率大概 4/16.67 = 25%。 16.67 是渲染帧间隔，那为什么是 4ms 呢？请看下文 setImmediate。</p>`,7),W={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame",target:"_blank",rel:"noopener noreferrer"},O=r(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>requestAnimationFrame(function () {
    document.body.style.background = &#39;red&#39;;
    requestAnimationFrame(function () {
        document.body.style.background = &#39;white&#39;;
    })
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入的任务会在每次渲染任务<strong>之前</strong>执行，因此等待渲染之后需要调用两次来插入到第二次渲染之前。 这样背景一定会闪现红色。同样下面页面的 “Switch background red and white” 部分给了例子，可以点点看：</p><p>http://harttle.github.io/async-and-render</p><h2 id="所以-setimmediate-是啥" tabindex="-1"><a class="header-anchor" href="#所以-setimmediate-是啥" aria-hidden="true">#</a> 所以 setImmediate 是啥</h2>`,4),U={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate",target:"_blank",rel:"noopener noreferrer"},V={href:"https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#sec-efficient-script-yielding",target:"_blank",rel:"noopener noreferrer"},B={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout",target:"_blank",rel:"noopener noreferrer"},D={href:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout",target:"_blank",rel:"noopener noreferrer"},H=e("blockquote",null,[e("ol",null,[e("li",null,"If timeout is less than 0, then set timeout to 0."),e("li",null,"If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4."),e("li",null,"Increment nesting level by one.")])],-1),R={href:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timer-nesting-level",target:"_blank",rel:"noopener noreferrer"},j=e("p",null,"https://github.com/YuzuJS/setImmediate/blob/master/README.md",-1);function Y(G,K){const s=o("ExternalLinkIcon");return l(),a("div",null,[c,e("ul",null,[e("li",null,[e("a",u,[t("渲染任务的时机"),n(s)])]),e("li",null,[e("a",m,[t("所以 setImmediate 是啥"),n(s)])])]),e("p",null,[t("JavaScript 是单线程的，但提供了很多异步调用方式比如 "),h,t("，"),p,t("，"),_,t("，"),g,t("，"),v,t("，"),b,t("， I/O，DOM 事件等。 这些异步调用的实现都是"),e("a",k,[t("事件循环"),n(s)]),t("，但根据插入的队列不同和取任务的时机不同他们的表现也不同。 尤其在涉及与页面渲染的关系时。")]),f,x,T,e("p",null,[t("JavaScript 的异步机制由 "),e("a",y,[t("事件循环"),n(s)]),t(" 实现，这些 API 的不同表现在进入和离开任务队列的时机。 为了讨论方便，先解释几个概念。")]),e("ul",null,[I,w,e("li",null,[P,t(" 在 Task Queue 的每个任务执行结束后，下一个任务执行开始前，会执行并清空 Microtask Queue 中的所有任务。在 Microtask 执行期间插入的任务也会进入当前 Microtask Queue。会加入 MicroTask 队列的包括："),e("a",M,[t("Promise"),n(s)]),t(", MutationObserver，process.nextTick。")])]),Q,e("ul",null,[e("li",null,[t("注意与 "),q,t(" 的回调不同，"),A,t(" 的回调是同步执行的。可参考 "),e("a",S,[t("Promise 回调的执行"),n(s)]),t(" 一文。")]),e("li",null,[t("在 Jake 的 "),e("a",E,[t("Tasks, microtasks, queues and schedules"),n(s)]),t(" 一文中有更加详细的例子，感兴趣的读者可前往观摩。")])]),z,e("p",null,[t("UI 渲染和交互的处理是通过 Task Queue 来调度的，因此耗时任务会导致渲染和交互任务得不到调用，也就是页面“卡死”。 典型的浏览器会在每秒插入 60 个渲染帧，也就是说每 16ms 需要一次渲染。 如果存在一个任务在 16ms 内未能执行结束，页面就会掉帧给人卡顿的感觉。 渲染帧的详细讨论可以参考 "),e("a",J,[t("浏览器的 16ms 渲染帧"),n(s)]),t(" 一文，也可以参考下面的例子：")]),N,e("ul",null,[C,e("li",null,[t("以 PC Chrome 为例，iOS Safari 尤其是 "),e("a",F,[t("UIWebview"),n(s)]),t(" 的表现可能会不同。")])]),L,e("p",null,[t("想要增大几率到 100% 怎么办？setTimeout 100ms 呗… 其实 HTML5 中给出了 "),e("a",W,[t("requestAnimationFrame"),n(s)]),t(" API，使得脚本有机会精确地控制动画：")]),O,e("p",null,[e("a",U,[t("setImmediate"),n(s)]),t(" 是由 IE 提出的， 目前尚未形成标准。当前状态是 "),e("a",V,[t("Proposal"),n(s)]),t(" 且只有 IE 有实现。 setImmediate 是为了让脚本更快地执行，与 "),e("a",B,[t("setTimeout"),n(s)]),t(" 一样都使用 Task Queue。 为了解 setImmediate 的用途，我们先看 setTimeout 为什么不够快。 下面的文本来自 "),e("a",D,[t("HTML5 Living Standard"),n(s)]),t(" 的 timer initialization steps:")]),H,e("p",null,[t("其中 nesting level 是指 "),e("a",R,[t("timer nesting level"),n(s)]),t("， 每一级可能是 setTimeout 也可能是 setInterval。也就是说在嵌套 5 层以上时，会设置最小 4ms 的延迟。由于没有广泛实现，使用 setImmediate 需要引入 Polyfill。请参考：")]),j])}const $=i(d,[["render",Y],["__file","事件循环是如何影响页面渲染的？.html.vue"]]);export{$ as default};
