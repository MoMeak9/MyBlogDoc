---
icon: edit
date: 2022-03-15
category:
- 面经
- 开水团
---

# 美团面经

> Q&A会对部分题目进行解答

### 北京美团地图部门

1. 对前端的应用领域专门理解？
2. 为什么JavaScript要设计成单线程
3. JavaScript闭包？
4. JavaScript异步变成
5. Promise如何实现？怎么设计的？简单说说PromiseA+实现思路
6. 进程和线程的区别？
7. 浏览器运行时有几个进程？
8. 浏览器为什么要多进程？
9. 为什么要有线程？线程的出现解决了什么？
10. 进程之间是怎么进行通信的？
11. 你知道的浏览器内核？
12. 浏览器渲染过程？
13. 输入URL到显示（网络方面？，补浏览器方面）
14. 三大加密算法
15. 数字证书是什么？
16. HTTP状态码404和500
17. 算法DFS 深度优先
18. 最长递增子序列



### 美团前端实习一面

1. 基本数据类型和复杂数据类型的区别

2. 判断是不是数组类型

   ```
   Array.isArray()
   .constructor
   instanceof
   toString()
   ```

3. 原型链

4. 问了个输出的题

   ```js
   console.log(a) //undefined
   var a = 100
   function fn(name) {
   	a = 20
   	console.log(name, 20) //'zhang',20
   	var a
   }
   fn('zhang')
   ```

   ```js
   var name = 'zhang'
   function fn(name) {
   	console.log(name) //undefined
   }
   fn()
   ```

5. bind、call、apply的区别

   > call、apply、bind都是改变this指向的方法
   > call：
   > 如果不传参数，或者第一个参数是null或nudefined，this都指向window
   > 严格模式：第一个参数是谁，this就指向谁，包括null和undefined，如果不传参数this就是undefined
   > apply：和call基本上一致，唯一区别在于传参方式
   > apply把需要传递给fn的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给fn一个个的传递
   > bind：语法和call一模一样，区别在于bind不会立即执行，bind不兼容IE6~8
   > 它返回的是一个函数，需要再次调用，才能获得bind后的结果

6. 闭包用过吗？

7. promise用过哪些方法？all、finally、race咋用？

   all全部执行，结果以数组返回，有一个reject就会全部reject

   finally最终都会执行

   race抢先返回执行成功的内容

8. css选择器的优先级怎么算？

   > 内联1000，id100 ,class伪类属性10，伪元素标签1，其余位0（比如继承的类型） !important 最高

9. 写一下水平居中的方法，讲一下position

10. 输入url后发生了什么？

    > （1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
    >
    > （2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新 的请求。
    >
    > （3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用 户。用户向本地DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
    >
    > （4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应 该为网关的地址。
    >
    > （5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接
    > 收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的
    > 确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立
    > 状态，此时双方的连接就建立起来了。
    >
    > （6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加
    > 密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
    >
    > （7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行
    > 解析，开始页面的渲染过程。
    >
    > （8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端
    > 是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建
    > 立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
    >
    > （9）最后一步是 TCP 断开连接的四次挥手过程。

11. 前端收到html、css、js后怎么处理

    > 根据html构建dom树，根据css构建cssom树，如果遇到script标签，要阻塞页面的渲染（下载并同步执行，是否并行下载根标签属性有关），说一下解决方法，最后根据dom树和cssom树构建渲染树，最后渲染上去

12. 重绘和回流

13. 为什么用虚拟dom

    > 大多数场景下，虚拟 DOM 能给你的页面过得去的性能，并且提供给你更爽的开发模式开发效率的提升
    >
    > **跨平台的问题**：虚拟 DOM 是对渲染内容的一层抽象描述，这就使得视图层和渲染层做了解耦。这层对渲染层的描述可以是 web、native、小程序等多端的，在不同端可能只需要一份代码就可以 work 。毕竟连 Vue3 也将 DOM 操作的内容提在一个独立的 runtime-dom.js 模块中，目的就是在多端操作渲染层的内容从而实现跨平台的可能性。

14. 用过vue?created和mounted的区别？

    > created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
    >
    > mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

15. 有两个蚊香，一个蚊香烧完是1h，怎么获得45min

    > 两个同时点，一根只点燃一方，一根两头同时燃，这样就能得到30min，这个时候另一个烧了一半，此时点燃另一头，就能再得15min

16. 编程题： [二叉树的最大深度](https://www.nowcoder.com/jump/super-jump/word?word=二叉树的最大深度)

    ```js
    function fn(root, depth) {
        if (root) {
            const depthL = fn(root.left, depth + 1)
            const depthR = fn(root.right, depth + 1)
            return Math.max(depthL, depthR)
        }
        else {
            return depth
        }
    }
    ```

17. 编程题：数组是否有重复值，写一下有哪些方法

18. 那写一下快排吧

    ```js
    function quickSort(arr, low, high) {
        if (low < high) {
            let index = getIndex(arr, low, high);
            quickSort(arr, low, index - 1);
            quickSort(arr, index + 1, high);
        }
    }
    
    function getIndex(arr, low, high) {
        let temp = arr[low]
        while (low < high) {
            while (low < high && arr[high] >= temp) {
                high--
            }
            arr[low] = arr[high]
            while (low < high && arr[low] <= temp) {
                low++
            }
            arr[high] = arr[low]
        }
        arr[low] = temp
        return low
    }
    ```

    

