---
icon: edit
date: 2022-03-19
category:
- 面经
- PDD
---



# 前端工程师面试手册

> [在线预览](https://my-doc-1259409954.cos.ap-guangzhou.myqcloud.com/pdf/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%8B%E5%86%8C.pdf?ci-process=doc-preview&dstType=html)

## 前端基础

###  HTTP/HTML/浏览器

####  说一下 HTTP 和 HTTPS

HTTPS 的 SSL 加密是在传输层实现的。

**(1)HTTP 和 HTTPS 的基本概念** 

HTTP: 超文本传输协议（基于TCP），它可以使浏览器更加高效，使网络传输减少。 

HTTPS: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 **HTTPS 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。** 

**(2)HTTP 和 HTTPS 的区别？**

HTTP 传输的数据都是未加密的，也就是明文的， SSL 协议来对 HTTP 协议传输的数据进行加密处理，简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传 输和身份认证的网络协议，比 HTTP 协议的安全性更高。 

**主要的区别如下：** 

HTTPS 协议需要 CA 证书，费用较高。 HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。 

使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443，HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输（非对称加密）、身份认证的网络协议，比 HTTP 协议安全。 

(3)HTTPS 协议的工作原理 

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤。 

客户使用 HTTPS url 访问服务器，则要求 web 服务器建立 ssl 链接。 

web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或 者说传输给客户端。 

客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 

客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 

web 服务器通过自己的私钥解密出会话密钥。 web 服务器通过会话密钥加密与客户端之间的通信。 

**(4)HTTPS 协议的优点** 

使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器HTTPS 协议是由 SSL+HTTP 协议构建的可进行**加密传输、身份认证的网络协议**，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻 击的成本。

**(5)https 协议的缺点** 

https 握手阶段比较**费时**，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 SSL 证书也需要钱，功能越强大的证书费用越高。 **SSL 证书需要绑定 IP**，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。

#### TCP 三次握手，一句话概括

C 发起请求连接 S 确认，也发起连接 C 确认我们 再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受 C 发送的报文段第 二次握手：C 可以确认 S 收到了自己发送的报文段，并且可以确认 自己可以接受 S 发 送的报文段第三次握手：S 可以确认 C 

#### TCP 和 UDP 的区别

（1）TCP 是面向连接的，UDP是无连接的即发送数据前**不需要先建立链接**。
（2）TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 TCP可靠，面向连接，不会丢失数据因此适合大数据量的交换。
（3）TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。
（4）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。
（5）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。
（6）TCP 是面向连接的可靠性传输，而 UDP 是不可靠的

####  WebSocket 的实现和应用

**(1)什么是 WebSocket?**

WebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，**HTTP1.1 中的 keep-alive，将多个 http 请求合并为 1 个。**

**(2)WebSocket 是什么样的协议，具体有什么优点？**

HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在 Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1 中进行了改进，是的有一个 connection： Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request，接收多个 Response。 但是必须记住，**在 Http 中一个 Request 只能对应有一个 Response，而且这个 Response 是被动的，不能主动发起。** 

WebSocket 是基于 Http 协议的，或者说**借用了 Http 协议来完成一部分握手**，在握手阶段 与 Http 是相同的。

#### HTTP 请求的方式，HEAD 方式

head：类似于 get 请求，只不过返回的响应中没有具体的内容，用户获取报头 

options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等

#### 说一下 web Quality（无障碍

能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。 残障人士指的是那些带有残疾或者身体不健康的用户。 使用 **alt 属性**： 

`<img src="person.jpg" alt="this is a person"/>`

有时候浏览器会无法显示图像。具体的原因有：

用户关闭了图像显示 

浏览器是不支持图形显示的迷你浏览器 

浏览器是语音浏览器（供盲人和弱视人群使用) 

如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述

#### 几个很实用的 BOM 属性对象方法

**(1)location 对象**

location.href-- 返回或设置当前文档的 URL

location.search -- 返回 URL 中的查询字符串部分

location.href-- 返回或设置当前文档的 URL

location.search -- 返回 URL 中的查询字符串部分。

location.hostname -- 返回 URL 中的主域名部分，

location.pathname -- 返回 URL 的域名后的部分。

**(2)history 对象**

history.go() -- 前进或后退指定的页面数 history.go(num);

history.back() -- 后退一页

history.forward() -- 前进一页

**(3)对象**

navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字
符串)
navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie

#### 说一下 http2.0

- 提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0）
- 允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限
  制（连接数量），超过限制会被阻塞。
- 二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二
- 进制编码
- 首部压缩
- 服务器端推送

#### 补充 400 和 401、403 状态码

**(1)400 状态码：请求无效**

产生原因：
前端提交数据的字段名称和**字段类型与后台的实体没有保持一致**
前端提交到后台的数据应该是 **json** 字符串类型，但是前端没有将对象 JSON.stringify 转化成字符串。
解决方法：
对照字段的名称，保持一致性
将 obj 对象通过 JSON.stringify 实现序列化

**(2) 401 状态码**：当前请求需要用户验证

**(3) 403 状态码**：服务器已经得到请求，但是**拒绝执行**

#### fetch 发送 2 次请求的原因

**<u>fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？</u>** 

原因很简单，因为你用 fetch 的 post 请求的时候，导致 **fetch 第一次发送了一个 Options 请求**，**询问服务器是否支持修改的请求头（更改传输的内容，如form表单，JSON等）**，如果服务器支持，则在第二次中**发送真正的请求**。

#### Cookie、sessionStorage、localStorage 的区

**共同点：**都是保存在浏览器端，并且是同源的

**Cookie：**cookie 数据始终在同源的 http 请求中携带**（即使不需要）**，即 cookie 在浏览器 和服务器间来回传递。（CSRF攻击）而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。

cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下, 存储的大小很小只有 4K 左右。 （key：可以在浏览器和服务器端来回传递，存储容量 小，只有大约 4K 左右，数量限制，子cookie解决，不同浏览器不同。）

**sessionStorage**：仅在当前浏览器窗口关闭前有效（刷新等都没事），自然也就不可能持久保持，

**localStorage**： 始终有效，窗口或浏览器关闭也一直保存，因此用作**持久数据**；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 localStorage：localStorage 在**所有同源窗口中都是共享的**；**cookie 也是在所有同源窗口中都是共享的**，sessionStorage用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）



P16
