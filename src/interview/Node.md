---
icon: edit
date: 2022-03-19
category:
- 面试题
- 前端
- Node.js
---

# Node.js 前端面试题

#### Node.js 与 JavaScript 有什么不同?

(宿主环境)

![img](https://mc-web-1259409954.cos.ap-guangzhou.myqcloud.com/MyImages/2ee2f07e9bce4fc9778bf05273645365.png)

#### 什么时候用 Node.js？

Node.js 是异步的、事件驱动的、非阻塞的和单线程的，使得它成为开发下面应用程序的完美候选：

- 实时应用程序，如聊天和提供实时更新的应用程序
- 将视频或其他多媒体内容流式传输给大量观众的流式应用程序
- 其他 I/O 密集型应用程序，如协作平台
- 遵循微服务架构的网络后端

然而，Node.js 的特性使得它对于其他类型的应用程序来说不是一个理想的选择。执行 CPU 密集型任务的应用程序（如复杂的数学计算）在使用 CPU 时表现不佳，因为 Node.js 是单线程的。

如果你想了解更多这方面的信息，请查看我们的文章 Node.js 架构以及何时在项目中使用。

#### 事件循环是什么?

单线程的 Node.js 必须是非阻塞的，以防止线程阻塞在需要很长时间才能完成的任务上，事件循环负责实现这种非阻塞行为，它使用应用程序线程调度挂起的任务。

Node.js 在**任务完成时通过回调**来处理异步函数返回的响应。与创建任务的事件类似，任务完成后也会发出一个事件。**Node.js 将需要处理的事件添加到事件队列**。

事件循环对事件队列中的事件进行迭代，并安排何时执行其关联的回调函数。

#### 流是什么?

Stream 流是**从源读取或写入数据并将其传输到连续流目标的<u>管道</u>**。有四种类型：

- 可读

- 可写的

- 可读写

- 先写入，再读出来

每个流也是一个 EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件。

#### readFile 和 createReadStream 函数有什么区别

readFile 函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户。

createReadStream 使用一个可读的流，逐块读取文件，而不是全部存储在内存中。

与 readFile 相比，createReadStream 使用更少的内存和更快的速度来优化文件读取操作。如果文件相当大，用户不必等待很长时间直到读取整个内容，因为读取时会先向用户发送小块内容。

#### 如何处理 Node.js 中未捕获的异常？

我们可以在**进程级别**捕获应用程序中未捕获的异常。为此将**侦听器附加到 process 全局对象**：

```js
process.on("uncaughtException", (err) => {  console.log("exception caught: ", err);});
```

####  Node.js 能否充分利用多核处理器？

（默认的）Node.js 应用程序总是单线程的，即使在多核处理器上运行，应用程序也能只使用一个处理器。

但是 Node.js 的核心模块之一 **Cluster** 支持 Node.js 应用程序开启多核，允许我们创建多个工作进程，这些进程可以在多个内核上并行运行，并共享一个端口来侦听事件。

每个进程使用 IPC 与主线程通信，并根据需要将服务器句柄传递给其他进程。主进程可以侦听端口本身并以循环方式将每个新连接传递给子进程，也可以将端口分配给子进程以便子进程侦听请求。

#### 单线程与多线程网络后端相比有哪些好处？

尽管 Node.js 是单线程的，但是大多数用于后端开发的编程语言都提供多线程来处理应用程序操作。

**为什么单线程有利于后端开发？**

- 开发人员更容易实现应用程序。我们的应用程序在生产过程中不会突然遇到意外的竞争条件。
- 单线程应用程序易于扩展。
- 它们可以毫不延迟地在一个时刻收到的大量用户请求提供服务。相比之下，当流量较大时，多线程后端必须等待线程池中的线程释放，才能为用户请求提供服务。**利用 Node.js 的非阻塞特性，用户请求不会在单个线程上挂起太长时间（只有在操作不是 CPU 密集型时）**。

#### process.nextTick 和 setImmediate 有什么区别？

传递给 setImmediate 函数的回调将在事件队列上的下一次迭代中执行。

另一方面，回调传递给 process.nextTick 在下一次迭代之前以及程序中当前运行的操作完成之后执行。在应用程序启动时，开始遍历事件队列之前调用它的回调。

因此，回调 process.nextTick 总是在 setImmediate 之前调用。

#### 什么是 yarn 和 npm？为什么要用 yarn 代替 npm 呢？

yarn 也是一个包管理器，为了解决 npm 的一些缺点。yarn 依赖 npm 注册中心为用户提供对包访问。**yarn 底层结构基于 npm**，如果从 npm 迁移到 yarn，项目结构和工作流不需要大改。

就像之前提到的，在某些情况下，yarn 提供了比 npm 更好的功能。**与 npm 不同的是，它会缓存下载的每个包，不必重新下载。**

**通过<u>校验和验证包的完整性</u>来提供更好的安全性，保证在某个系统上运行的包在任何其他系统中的工作方式完全相同，这就是为什么选择 yarn 而不是 npm 来进行包管理。**
